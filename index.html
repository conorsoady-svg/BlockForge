<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
<meta name="format-detection" content="telephone=no" />
<title>Block Forge Full Game (Neon, Mobile, Demo AI)</title>
 <link rel="manifest" href="./manifest.webmanifest">
<link rel="icon" type="image/png" sizes="192x192" href="./icons/192x192.png">
<link rel="apple-touch-icon" href="./icons/192x192.png">
<meta name="theme-color" content="#0c1226">


<style>
:root{--cell:40;--gap:2;--pad:4;--clear-ms:420;--cols:8}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;-webkit-text-size-adjust:100%}
body{margin:0;background: radial-gradient(circle farthest-corner at 50% 50%, #010724 70%, #3A5292 150%); background-attachment: fixed; background-size: 100dvw 100dvh; background-repeat: no-repeat; background-position: center;color:#54FF10;text-align:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overscroll-behavior-y:none;-webkit-user-select:none;user-select:none}
.hidden{display:none!important}


/* --- Update toast (PWA) --- */
#updateToast {
  position: fixed;
  left: 50%;
  bottom: 16px;
  transform: translateX(-50%) translateY(20px);
  background: rgba(12,18,38,.92);
  color: #e8ebf3;
  border-radius: 12px;
  padding: 10px 14px;
  box-shadow: 0 10px 24px rgba(0,0,0,.35), 0 0 14px rgb(0, 247, 255);
  display: none;
  z-index: 9999;
  font-weight: 700;
  letter-spacing: .2px;
}
#updateToast.show { display: flex; gap: 10px; align-items: center; }
#updateToast button {
  margin: 0;
  padding: 6px 10px;
  font-size: 14px;
  border: none;
  border-radius: 10px;
  background: #111827;
  color: #00fff2;
  cursor: pointer;
}
#updateToast button.primary { background:#00ffea; color:#0b1022; font-weight:900; }
#updateToast button:hover { background: #1f2937; box-shadow: 0 0 12px rgb(0, 247, 255); }
#updateToast button:active { transform: translateY(1px); }





/* UI */
button{
  margin:6px;
  padding:15px 20px;
  font-size:16px;              /* â† fix */
  border:none;
  border-radius:12px;
  background:#111827;
  color:#00ffea;
  cursor:pointer;
  box-shadow:0 0 8px rgb(0, 255, 234);
  transition:background .2s, box-shadow .2s, transform .06s;
}
button:active{ transform:translateY(1px); }

/* Offline = teal */
#homeOfflineBtn{
  background:linear-gradient(#264bc5, #002c6e); color:#ffffff;
  border:1px solid rgba(0,224,212,.35);
  box-shadow:0 0 0px rgba(0,224,212,.35), 0 0 2px rgba(0,224,212,.6) inset;
font-size: 20px;
font-style: italic;
font-weight: bold;
}

/* Online = purple */
#homeOnlineBtn{
  background:linear-gradient(#f89500, #583d00); color:#ffffff;
  border:1px solid rgba(167,125,255,.35);
  box-shadow:0 0 0px rgba(167,125,255,.35), 0 0 2px rgba(167,125,255,.6) inset;
  font-size: 20px;
  font-style: italic;
  font-weight: bold;
}

/* Theme = amber */
#homeThemeBtn{
  background:linear-gradient(#ff0000, #470202); color:#ffffff;
  border:1px solid rgba(255,178,71,.35);
  box-shadow:0 0 0px rgba(255,178,71,.35), 0 0 2px rgba(255,178,71,.6) inset;
  font-size: 20px;
  font-style: italic;
  font-weight: bold;
}

.app{
  width:100%;
  max-width:min(560px, 92vw);
  margin:0 auto;
  padding:16px;
  position:relative;
  z-index:1;
}


.sub{opacity:.8;margin-bottom:8px}


#home .home-layout > button:not(.icon-btn){
  --btnw: clamp(140px, 40vw, 220px);
  min-width: var(--btnw);
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}
#home .home-layout > button:not(.icon-btn):active{
  transform: translate(-50%, 1px);
}




/* --- PIN SETTINGS ICON TO SCREEN CORNER (first page only) --- */
/* Neutralize any earlier absolute positioning */

#homeSettingsBtn{
  position: fixed !important;
  z-index: 2000;
  top:  max(env(safe-area-inset-top), 10px) !important;
  right:max(env(safe-area-inset-right), 10px) !important;
  left: auto !important;
  transform: none !important;
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
  padding: 10px;
  line-height: 0;
  color: #00ffea;
}
#homeSettingsBtn svg{
  width: clamp(80px, 4vw, 60px);
  height: clamp(80px, 4vw, 60px);
  fill: currentColor;
}
#homeSettingsBtn:active{ transform: none !important; }
#homeSettingsBtn:active svg{ transform: translateY(1px); }


/* If your global button:active applies translateY(1px) to all buttons,
   this prevents the container from moving (only the SVG moves). */
#homeSettingsBtn:active{ transform: none !important; }




/* === Clamp & free placement: FIRST PAGE ONLY (#home) === */
#home { position: relative; }

/* Positions (edit the clamp values to taste) */
#homeOfflineBtn {
  top:  clamp(560px, 18dvh, 158px);
  right: clamp(200px, 5vw, 200px);
}
#homeOnlineBtn  {
  top:   clamp(640px, 18dvh, 158px);
  right: clamp(200px, 5vw, 200px);
}
/* Center Theme using the same clamped width */
#homeThemeBtn   {
  top:  clamp(720px, 18dvh, 158px);
  left: calc(200px, 5vw, 200px);
}




/* Boards */
.board-wrap{position:relative;display:inline-block}
.board{display:grid;grid-template-columns:repeat(var(--cols),calc(var(--cell)*1px));gap:calc(var(--gap)*1px);background:#020724;box-shadow: 0 0 10px rgba(0, 247, 255, 0.61);padding:calc(var(--pad)*1px);border-radius:16px;position:relative;width:calc(var(--cols) * var(--cell) * 1px + (var(--cols) - 1) * var(--gap) * 1px + 2 * var(--pad) * 1px);overflow:hidden}
.cell{width:calc(var(--cell)*1px);height:calc(var(--cell)*1px);background:#0A0F28;border-radius:10px;position:relative;overflow:hidden;will-change:transform,opacity}
.block{box-shadow:inset 0 2px 0 rgb(255, 1, 1),inset 0 -3px 0 rgb(255, 1, 1),0 0 12px rgb(255, 0, 0);background-image:radial-gradient(120% 90% at 20% 10%, rgb(255, 0, 0), rgb(255, 0, 0) 55%),linear-gradient(180deg, rgb(255, 0, 0), rgb(255, 9, 9))}



/* Animations */
@keyframes pop{0%{transform:scale(1)}50%{transform:scale(1.16)}100%{transform:scale(1)}}
@keyframes waveIn{0%{transform:scale(.7);opacity:.15}45%{transform:scale(1.15);opacity:1}100%{transform:scale(1);opacity:1}}
@keyframes waveOut{0%{transform:scale(1);opacity:1}60%{transform:scale(1.08)}100%{transform:scale(.85);opacity:.05}}
@keyframes jumpOut{0%{transform:scale(1)}55%{transform:scale(1.24)}100%{transform:scale(1)}}
@keyframes clearPulse{0%{transform:scale(1);filter:brightness(1);opacity:1}40%{transform:scale(1.06);filter:brightness(1.6)}70%{transform:scale(1)}100%{opacity:0;transform:scale(0.88)}}
@keyframes sweepH{0%{left:-120%}100%{left:120%}}
@keyframes sweepV{0%{top:-120%}100%{top:120%}}
.clearing{animation:clearPulse calc(var(--clear-ms) * 1ms) ease-in forwards;animation-delay:var(--cDelay,0ms);position:relative}
.clearing::after{content:"";position:absolute;inset:-40% -10%;pointer-events:none;background:linear-gradient(120deg, rgba(255,255,255,0), rgba(255,255,255,.9), rgba(255,255,255,0));opacity:.7}
.clearing.row::after{top:50%;height:40%;transform:translateY(-50%);left:-120%;animation:sweepH calc(var(--clear-ms) * 1ms) ease-out forwards;animation-delay:var(--cDelay,0ms)}
.clearing.col::after{left:50%;width:40%;transform:translateX(-50%);top:-120%;animation:sweepV calc(var(--clear-ms) * 1ms) ease-out forwards;animation-delay:var(--cDelay,0ms)}

/* Preview */
.preview-layer{position:absolute;left:0;top:0;pointer-events:none}
.preview-block{width:calc(var(--cell)*1px);height:calc(var(--cell)*1px);border-radius:10px;position:absolute;opacity:.6;box-shadow:0 0 12px rgba(0,255,170,.45);outline:2px dashed rgba(255,255,255,.25);outline-offset:-3px}
.preview-layer.valid .preview-block{box-shadow:0 0 0 2px rgba(0,255,170,.85),0 0 12px rgba(0,255,170,.6)}
.preview-layer.invalid .preview-block{box-shadow:0 0 0 2px rgba(255,0,120,.85),0 0 12px rgba(255,255,255,.6)}

/* Tray */
#tray{display:grid;grid-template-columns:repeat(3,max-content);gap:16px;justify-content:center;margin:14px auto 8px}
.piece.slot{display:flex;align-items:center;justify-content:center;background:transparent;border-radius:0;padding:0;min-width:auto;min-height:auto;box-shadow:none}
#tray .placeholder{opacity:.25}

/* Overlays */
#overlay,#backMenu{position:fixed;inset:0;background:rgba(0,0,0,.6);display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:5}
#overlay.hidden,#backMenu.hidden{display:none!important}

/* Game container */
#game{position:relative;padding-top:clamp(28px,6vh,60px)}

/* Tetris: square corners only in tetris mode */
.tetris .cell{border-radius:3px}
.tetris .preview-block{border-radius:3px}

/* Keep the home/background demo normal-sized */
.stage .board{--cell:40 !important}

/* On-screen Tetris controls: responsive */
#tetrisControls button{
  min-width:clamp(44px,8vw,64px);
  padding:clamp(6px,1.3vh,10px) clamp(10px,2.2vw,16px);
  font-size:clamp(12px,1.8vh,16px);
}

#score{position:absolute;top:6px;left:50%;transform:translateX(-50%);font-size:32px;color:#39ff14;text-shadow:0 0 8px rgba(57,255,20,.8)}

/* Background demo stage */
.stage{position:fixed;inset:0;display:flex;align-items:flex-start;justify-content:center;pointer-events:none;z-index:0;opacity:.45;filter:saturate(1.08) brightness(1.06)}
.stage .board-wrap{position:relative;margin-top:220px}
.stage .board{--cols:8;transform:scale(.9);overflow:hidden;width:calc(8 * var(--cell) * 1px + 7 * var(--gap) * 1px + 2 * var(--pad) * 1px)}
.stage .score-banner{position:absolute;top:-40px;left:50%;transform:translateX(-50%);font-weight:900;font-size:28px;background:rgba(0,0,0,.35);padding:6px 12px;border-radius:12px;white-space:nowrap}
.stage .tray{display:grid;grid-template-columns:repeat(3,max-content);gap:12px;justify-content:center;margin-top:10px}
.stage .tray .placeholder{opacity:.25}
@keyframes demoDrag{0%{transform:translateY(90px) scale(.92);opacity:0}60%{opacity:.7}100%{transform:translateY(0) scale(1);opacity:.6}}

/* Touch */
#board,#boardWrap,.piece.slot,.preview-layer{touch-action:none}

/* --- HUD / feedback --- */
#hudLayer{position:absolute; inset:0; pointer-events:none; z-index:4; display:flex; align-items:flex-start; justify-content:center;}
#comboBanner{position:absolute; top:44px; left:50%; transform:translateX(-50%); padding:6px 12px; border-radius:12px; background:rgba(0,0,0,.45); font-weight:800; letter-spacing:.5px; box-shadow:0 0 14px rgba(57,255,20,.35); opacity:0; transition:opacity .18s, transform .18s;}
#comboBanner.show{ opacity:1; transform:translateX(-50%) translateY(0) scale(1); }
#comboBanner.bump{ animation:comboBump .25s ease; }
@keyframes comboBump{0%{ transform:translateX(-50%) scale(.92);}60%{ transform:translateX(-50%) scale(1.08);}100%{ transform:translateX(-50%) scale(1);}}
.score-pulse{ animation:scorePulse .22s ease; }
@keyframes scorePulse{0%{ transform:translateX(-50%) scale(1); filter:brightness(1);}50%{ transform:translateX(-50%) scale(1.18); filter:brightness(1.4);}100%{ transform:translateX(-50%) scale(1); filter:brightness(1);}}
.toast{position:absolute; top:86px; left:50%; transform:translateX(-50%); font-weight:800; padding:4px 10px; border-radius:10px; background:rgba(12,18,38,.75); box-shadow:0 6px 16px rgba(0,0,0,.35); opacity:0; animation:toastRise .7s ease forwards;}
@keyframes toastRise{0%{ transform:translate(-50%, 8px) scale(.9); opacity:0; }20%{ opacity:1; }100%{ transform:translate(-50%,-20px) scale(1.0); opacity:0; }}

/* Floating points for placements/clears */
.float-score{position:absolute; top:86px; left:50%; transform:translateX(-50%) translateY(6px) scale(.9); font-weight:900; padding:2px 8px; border-radius:10px; background:rgba(12,18,38,.65); box-shadow:0 6px 16px rgba(0,0,0,.35); opacity:0; animation:floatUp .8s ease-out forwards; pointer-events:none;}
@keyframes floatUp{0%{ transform:translateX(-50%) translateY(6px)   scale(.9);  opacity:0; }20%{ opacity:1; }100%{ transform:translateX(-50%) translateY(-26px) scale(1.0); opacity:0; }}

/* Make combo banner flare when level increases */
#comboBanner.levelUp{ animation:comboBump .25s ease, comboGlow .8s ease; }
@keyframes comboGlow{0%{ box-shadow:0 0 0 rgba(57,255,20,0);}40%{ box-shadow:0 0 20px rgba(57,255,20,.8);}100%{ box-shadow:0 0 0 rgba(57,255,20,0);}}

/* Make sure foreground UI is always clickable on mobile */
.stage{ z-index:0 !important; pointer-events:none !important; }
.app{ position:relative; z-index:2 !important; }
#home button, #offline button, #online button, #game button{ pointer-events:auto; }

/* Safety: if any full-screen layer accidentally shows, force it behind */
#overlay.hidden, #backMenu.hidden{ display:none !important; }
#overlay, #backMenu{ z-index: 5; }  /* higher than .app only when visible */

/* Tetris on-screen controls (mobile) */
#tetrisControls{display:none;gap:8px;justify-content:center;margin:8px 0}
#tetrisControls button{min-width:64px}

/* ===== Neon portrait home â€” reference match ===== */
:root{ --hf-green:#65ff57; --hf-cyan1:#7bf5ff; --hf-cyan2:#22d6ff; }

#homeOverlay{
  position:fixed; inset:0; z-index:10000;
  display:none; align-items:flex-start; justify-content:center;
  min-height:100svh; height:100dvh;
  --homeOffset: clamp(28px, 8svh, 120px); /* push card down */
  background:#000D27;
  backdrop-filter: blur(6px);
  padding:
    max(10px, env(safe-area-inset-top))
    max(10px, env(safe-area-inset-right))
    max(16px, env(safe-area-inset-bottom))
    max(10px, env(safe-area-inset-left));
}
#homeOverlay.show{ display:flex; }

/* phone card */
.hf-phone{
  width:clamp(420px, 33vw, 420px);
  display:flex; flex-direction:column; align-items:center; gap:16px;
  margin-top: var(--homeOffset);
}

/* framed board */
.hf-board{
  position:relative; width:111%; aspect-ratio:9/11.2;
  border-radius:15px; overflow:hidden; padding:14px;
  background: #010722;
  box-shadow:
    0 0 28px rgba(0,255,255,.25),
    0 10px 28px rgba(0,0,0,.45),
    inset 0 0 0 1px rgba(255,255,255,.12),
    inset 0 6px 16px rgba(0,0,0,.35);
  
}
/* inner vignette */
/*.hf-board::before{
  content:""; position:absolute; inset:0; pointer-events:none;
  background:
    radial-gradient(80% 100% at 50% 20%, rgba(0,0,0,.0), rgba(0,0,0,.28) 70%),
    linear-gradient(180deg, rgba(0,0,0,.25), rgba(0,0,0,0) 20%, rgba(0,0,0,0) 80%, rgba(0,0,0,.35));
}

/* sparkles */
.hf-sparkles{
  position:absolute; inset:0; pointer-events:none;
  background:
    radial-gradient(6px 6px at 20% 30%, rgba(124,87,255,.45), transparent 55%),
    radial-gradient(5px 5px at 78% 60%, rgba(124,87,255,.35), transparent 60%),
    radial-gradient(4px 4px at 12% 70%, rgb(255, 255, 255), transparent 60%);
  animation:infinite 6s linear infinite; filter: blur(1px); opacity:.55;
}
@keyframes hfDrift{ 0%{transform:translateY(0)} 50%{transform:translateY(-6px)} 100%{transform:translateY(0)} }

/* title */
.hf-title{
  position:absolute; left:69px; top:30px; z-index:2;
  margin:0; text-align:center; letter-spacing:1px; line-height:.9;
  color:#53FF11; font-weight:800;
  font-size:clamp(92px, 12vw, 92px);
  text-shadow:0 0 10px rgb(9, 255, 0), 0 0 40px rgba(101,255,87,.25);
  pointer-events:none;
  font-family: 'Microsoft Sans Serif';
}

/* compact 8Ã—12 grid */
.hf-grid{
  --hfCell: clamp(50px, 5.2vw, 30px);
  position:absolute; left:50%; top:60%; transform:translate(-50%,-50%);
  display:grid; gap:4px;
  grid-template-columns:repeat(8,var(--hfCell));
  grid-template-rows:repeat(8,var(--hfCell));
  

}
/* empty cell */
.hf-cell{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: #020723;         /* dimmer empties */
  box-shadow: inset 0 2px 0 #020723, inset 0 -3px 0 #020723;
  
}
/* center dark '+' cluster */
.hf-ghost{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: #0B102A;
  box-shadow:none;
  color: #0B102A;
}
/* more ghosts */
.hf-ghost2{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: #0B102A;
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost3{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(180deg, #090F27, #0C112D 100%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost4{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(180deg, #001126, #0C102D 100%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost5{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(90deg, #010C25, #080F28 100%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost6{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(90deg, #080F28, #010C25 100%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost7{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(180deg, #000C25, #000C25 100%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost8{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(225deg, #010722, #020B26 110%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost9{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(180deg, #0B152B 0%, #02303D 100%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost10{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(270deg, #0B152B 0%, #02303D 100%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost11{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: #0B152B;
  box-shadow:none;
  color: #0B102A;
}
/* colored blocks (gloss + glow) */
.hf-block{
  width:var(--hfCell); height:var(--hfCell); border-radius:10px;
  box-shadow: 0 0 18px rgba(255, 255, 255, 0.35),
              inset 0 2px 0 rgba(255, 255, 255, 0.60),
              inset 0 -3px 0 rgba(0, 0, 0, 0.35);
}
.hf-cyan   { background:linear-gradient(180deg,#7bf5ff,#00B5E5); }
.hf-magenta{ background:linear-gradient(180deg,#FF31F4,#9F0BDB); }
.hf-orange { background:linear-gradient(180deg,#FEA019,#CD7317); }

/* PLAY button */
.hf-cta{
  display:block; width:min(320px, 82%);
  font-weight:900; letter-spacing:3px;
  font-size:clamp(50px,3.6vw,28px);
  font-family: 'Microsoft Sans Serif';
  padding:16px 24px; border-radius:9999px; border:0; cursor:pointer;
  color:#000000;
  background:linear-gradient(180deg, var(--hf-cyan1), var(--hf-cyan2));
  box-shadow:
    
    0 0 0 5px #00B3D0 inset,
    0 0 1px rgb(0, 225, 255);
}
.hf-cta{background: linear-gradient(180deg,#00F2E4,#0083C7);
 
  transition:transform .25s ease, filter 1.5s ease;}


.hf-cta:active{ transform:translateY(+6px) scale(1); }

/* mini cards with small block grids */
.hf-tray{ display:flex; gap:14px; justify-content:center; align-items:center; }
#tray table{border-collapse:collapse}
#tray td{padding:0}
#tray .block{border-radius:10px}




.hf-mini{

 --m: clamp(30px, 2.8vw, 26px);
--g: calc(var(--m) / 13);                /* gap size (tweak this) */
 display:grid; 
 grid-template-columns: repeat(4, var(--m)); 
 gap: var(--g);                           /* adds space between squares */
}



/* Nudge the mini grid inside each card */
#homeOverlay .hf-tray .hf-card:nth-child(1) .hf-mini { position: relative; left: -2px; top: 12px; }
#homeOverlay .hf-tray .hf-card:nth-child(2) .hf-mini { position: relative; left:  15px; top: -15px; }
#homeOverlay .hf-tray .hf-card:nth-child(3) .hf-mini { position: relative; left:  15px; top: -2px; }

/* Base cells = invisible, keep grid positions */
.hf-mini .b{
  width:var(--m); height:var(--m);
  border-radius:0;            /* square corners like the game */
  background:transparent;     /* no fill for empty cells */
  box-shadow:none;            /* no faint edges on empty cells */
}

/* Only the COLOURED cells get the bevel/glow */
.hf-mini .b.mag{
  border-radius: 5px;  /* rounded corners for blocks */
  box-shadow: 0 0 5px rgb(255, 0, 0),
              inset 0 1px 0 rgba(255,255,255,.22),
              inset 0 -2px 0 rgba(0,0,0,.35);
}
.hf-mini .b.vio{
  border-radius: 5px;  /* rounded corners for blocks */
  box-shadow: 0 0 10px rgb(140, 0, 255),
              inset 0 1px 0 rgba(255,255,255,.22),
              inset 0 -2px 0 rgba(0,0,0,.35);
}
.hf-mini .b.orn{
  border-radius: 5px;  /* rounded corners for blocks */
  box-shadow: 0 0 5px rgb(51, 255, 0),
              inset 0 1px 0 rgba(255,255,255,.22),
              inset 0 -2px 0 rgba(0,0,0,.35);
}

.hf-mini .mag{ background:linear-gradient(180deg,#ff0000,#ff0000b4); }
.hf-mini .vio{ background:linear-gradient(180deg,#7A5CFF,#7c82ff); }
.hf-mini .orn{ background:linear-gradient(180deg,#9AFF00,#4bb630); }

:root{
  --base-w: 420;                 /* design width (px) */
  --base-h: 820;                 /* design height (px) */
  --ratio: calc(var(--base-w) / var(--base-h));
  --app-h: 100dvh;               /* mobile-safe viewport height */
  --max-game-w: 550px;           /* <- cap how wide the game can get */
}
@supports not (height: 100dvh) { :root { --app-h: 100vh; } }

html, body {
  height: 100%;
  margin: 0;
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
}
*, *::before, *::after { box-sizing: border-box; }
img, canvas, svg, video { max-width: 100%; height: auto; display: block; }
button, input, select, textarea { font: inherit; }

/* FULL-SCREEN 2nd screen background; center content */
/*.fitstage{
  min-height: var(--app-h);
  width: 100vw;
  display: grid;
  place-items: center;
  overflow: hidden;
  background: #0c121b;
  padding: env(safe-area-inset-top) env(safe-area-inset-right)
           env(safe-area-inset-bottom) env(safe-area-inset-left);
}

/* THE GAME AREA with locked aspect;
   - Sized by HEIGHT (not vw) so gutters don't squish it
   - Hard cap on width via --max-game-w
*/
.fitbox{
  aspect-ratio: var(--base-w) / var(--base-h);
  width: min(100%, calc(var(--app-h) * var(--ratio)));
  max-width: var(--max-game-w);
  max-height: var(--app-h);
  overflow: hidden;
}

.fitbox *{ min-width:0; min-height:0; }

#demoStage,
#demoWrap,
#demoBoard,
#demoPreview,
#demoScore,
#demoTray {
  display: none !important;
}
#demoScore, .stage .score-banner {
  display: none !important;
}

/* Mini banner wrapper: allow the board's shadow to show */
#home .mini-stage{
  position: relative;
  width: min(350px, 92vw);
  height: clamp(360px, 28vh, 260px);
  margin: 10px auto 8px;
  pointer-events: none;
  background: transparent;
  filter: none;
  opacity: 1;
  /* was: overflow:hidden;  â† remove it so box-shadow isn't clipped */
  overflow: visible;
  z-index: 1;
}


/* Board fills the banner; its box-shadow can now extend freely */
#home .mini-stage #miniBoardClone{
  position: absolute; inset: 0; margin: auto;
  --cols: 8; --gap: var(--gap, 6); --pad: var(--pad, 8);
  z-index:1;                         /* above the pseudo background */
  
}

/* Canvas overlay for the ghost piece */
#home .mini-stage #homeMiniCanvas{
  position:absolute; inset:0; width:100%; height:100%;
  background: transparent; display:block; pointer-events:none;
  z-index:2;
}

/* Mini grid spacing (between squares) */
#home .mini-stage #miniBoardClone{
  position: absolute;
  --gap: 2;      /* â† gap in px (no unit in the var) */
  --pad: 3; 
   z-index: 2;     /* â† padding around the whole grid (px) */
  /* if you want to hard-override, add: gap: 10px !important; padding: 8px !important; */
}

.bfmini-piece{
  display: grid;
  gap: calc(var(--gap) * 1px);
  border-radius: 12px;
  background: transparent;
  outline: none;
  cursor: grab;
  touch-action: none;
  user-select: none;
}

.bfmini-piece.dragging{ opacity:.75; cursor: grabbing; }
.bfmini-piece:active{ transform:none; } /* donâ€™t inherit global press shift */

/* Each tray piece can have its own scale */
.bfmini-piece .cell{
  /* var(--cell) comes from the board; --piece-scale is per-piece */
  width:  calc(var(--cell, 40) * var(--piece-scale, 0.8) * 1px);
  height: calc(var(--cell, 40) * var(--piece-scale, 0.8) * 1px);
  border-radius: 8px;
  background: none;
  box-shadow: inset 0 0 2px rgba(255,255,255,.06),
              0 0 8px var(--glow, rgba(0,255,234,.10));
  outline: none;
}


/* If you put the module on #offline, it still works; no selector change needed */
#miniBoardClone.board{
  position: absolute;
  inset: 0;
  margin: auto;
  z-index: 2;                          /* above the wrapper bg */
}
/* --- Mini tray with 3 draggable pieces --- */
.bfmini-tray{
  margin: 12px auto 0;
  display: flex;
  gap: 14px;
  justify-content: center;
  pointer-events: auto;      /* allow dragging */
}

/* Pieces: small grid of cells */
.bfmini-piece{
  display: grid;
  gap: 4.5px;
  border-radius: 12px;
  background: transparent;
  outline: none;
  cursor: grab;
  touch-action: none;
  user-select: none;
}
.bfmini-piece.dragging{ opacity:.75; cursor: grabbing; }
.bfmini-piece:active{ transform:none; }

/* Cells inside pieces (slightly smaller than board cells) */
.bfmini-piece .cell{
  width: calc(var(--cell, 40) * 0.8px);
  height: calc(var(--cell, 40) * 0.8px);
  border-radius: 8px;
  background: none;
  box-shadow: inset 0 0 2px rgba(255,255,255,.06), 0 0 8px rgba(0,255,234,.10);
  outline: none;
}

/* Tray piece cells use the same variables so preview matches */
.bfmini-piece .cell{
  width: calc(var(--cell, 40) * 0.8px);
  height: calc(var(--cell, 40) * 0.8px);
  border-radius: 8px;
  background: none;
  box-shadow: inset 0 0 2px rgba(255,255,255,.06), 0 0 8px var(--glow, rgba(0,255,234,.10));
  outline: none;
}

.board .cell.hover-ok{  background: var(--fill, #04ff19); /* â† one-liner: uses the hovered pieceâ€™s color; falls back to green */
  border-radius:8px;
  box-shadow: 0 0 1px rgba(255, 255, 255, 0.35),
              inset 0 2px 0 rgba(255, 255, 255, 0.60),
              inset 0 -3px 0 rgba(0, 0, 0, 0.35); }

/* Kill the floating canvas overlay, keep DOM happy */
#homeMiniCanvas { display: none !important; }
.board .cell{ overflow: visible; }

/* Filled board cells use per-piece vars */
.board .cell.filled{
  background: var(--fill, #0f2b19);
  outline: 1px solid var(--stroke, rgba(57,255,20,.35));
  box-shadow:
    inset 0 0 3px var(--glow-inset, rgba(57,255,20,.35)),
    0 0 8px var(--glow, rgba(57,255,20,.22));
    z-index: 4;
}

/* Tray piece cells pick up the same vars */
.bfmini-piece .cell{
  width: calc(var(--cell, 40) * 0.8px);
  height: calc(var(--cell, 40) * 0.8px);
  border-radius: 8px;
  background: var(--fill, #0e1324);
  outline: 1px solid var(--stroke, rgba(0,255,234,.18));

}

/* SAFE tray layout (centered, below banner) */
#bfTray.bfmini-tray{
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 14px;
  align-items: center;
  justify-items: center;
  margin: 12px auto 0;
  max-width: min(560px, 92vw);
  position: relative;
  z-index: 1;              /* â† tray below grid */
}

/* Grid above tray so placed cells are visible */
#homeMiniDemo.mini-stage{ position: relative; z-index: 2; }
#miniBoardClone.board{ position: relative; z-index: 3; }

/* GAME screen keeps absolute pieces (if you use it there) */
#game #bfTray .bfmini-piece{ position: absolute; }

/* MODE page (#home): pieces should participate in grid layout */
#home #bfTray .bfmini-piece{
  position: static;           /* â† stops overlapping / makes gap work */
  transform: none !important; /* ignore any scale/translate from JS */
  margin-top: -30px;          /* keep your vertical nudge, edit here */
}





/* Ensure the grid sits above anything below it */
#homeMiniDemo.mini-stage{ position: relative; z-index: 2; }
#miniBoardClone.board{ position: relative; z-index: 3; }



/* If you still had an old ghost canvas, hide it hard */
#homeMiniCanvas{ display:none !important; }

/* Row/column clear effect */
.board .cell.clearing{
  animation: bfClear 240ms ease-in-out forwards;
}
@keyframes bfClear{
  0%{ transform: scale(1);   opacity: 1; }
  100%{ transform: scale(.6); opacity: 0; }
}
/* Board cells inherit the piece's colors/gradients */
.board .cell.filled{
  background: var(--fill) !important;            /* gradient or solid from the piece */
  outline: 1px solid var(--stroke, rgba(0,0,0,.3));
  width:var(--hfCell); height:var(--hfCell); border-radius:8px;
  box-shadow: 0 0 1px rgba(255, 255, 255, 0.35),
              inset 0 2px 0 rgba(255, 255, 255, 0.60),
              inset 0 -3px 0 rgba(0, 0, 0, 0.35);}
/* Make tray/board cells host a sheen overlay */
.bfmini-piece .cell,
.board .cell{
  position: relative;          /* needed so ::before sits on each square */
  overflow: hidden;            /* clip the sheen to the rounded square */
  border-radius: 8px;          /* match whatever radius you use */
}

/* Sheen for tray cells + placed board cells */
.bfmini-piece .cell::before,
.board .cell.filled::before{
  content: "";
  position: absolute;
  inset: 0;
  border-radius: inherit;
  pointer-events: none;

  /* bright hairline at top â†’ fade â†’ subtle dark at bottom */
  background:
    linear-gradient(
      to bottom,
      rgba(255,255,255,.45) 0px,
      rgba(255,255,255,.28) 2px,
      rgba(255,255,255,0) 28%,
      rgba(0,0,0,0)       72%,
      rgba(0,0,0,.22)    100%
    );

  /* makes the highlight pop over gradients without washing color */
  mix-blend-mode: screen;
  opacity: 0.9;
}

/* Optional: keep preview cells clean when the bot hovers invalid spots */
.board .cell.hover-bad::before { opacity: 0; }

/* Optional: a touch stronger sheen when preview is valid */
.board .cell.hover-ok::before  { opacity: 1; }

/* Fix grid track size so rows never reflow during effects */
#miniBoardClone.board{
  grid-auto-rows: calc(var(--cell, 40) * 1px);
}

/* Use a fade-only clear on BOARD cells (no scale â†’ no layout jitter) */
.board .cell.filled.clearing{
  animation: bfClearFade 240ms ease-out forwards;
}

@keyframes bfClearFade{
  from { opacity: 1; }
  to   { opacity: 0; }
}

/* 3 equal, fixed positions; each slot centers its content */
#bfTray.bfmini-tray{
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 16px;
  align-items: stretch;
  justify-items: stretch;
  margin: 12px auto 0;
  max-width: min(560px, 92vw);
  position: relative;
  z-index: 1;
}

/* Each slot is a little stage that centers the piece */
#bfTray .slot{
  display: grid;
  place-items: center;
  min-height: calc(var(--cell, 40) * 3px + 16px);  /* room for tall shapes */
}

/* Make sure pieces size to their content and stay centered */
#bfTray .slot > .bfmini-piece{
  display: grid;
  place-items: center;
}

/* Slots anchor pieces; they don't disappear or shift */
#bfTray .slot{
  display: grid;
  place-items: center;
  min-height: calc(var(--cell, 40) * 3px + 16px); /* room for tall shapes */
}

/* Make sure the piece centers inside the slot */
#bfTray .slot > .bfmini-piece{
  display: grid;
  place-items: center;
}


/* default */
#bfTray .bfmini-piece{ box-shadow: none; border-radius: 12px; }

/* per-colour shadows using data-tint (edit RGBA freely) */

/* cyan */
#bfTray .bfmini-piece[data-tint="0"]{
  filter:
    drop-shadow(0 0 3px rgba(0,181,229,1))

}
/* magenta */
#bfTray .bfmini-piece[data-tint="1"]{
  filter:
    drop-shadow(0 0 3px rgba(255,49,244,1))
}
/* orange */
#bfTray .bfmini-piece[data-tint="2"]{
  filter:
    drop-shadow(0 0 3px rgba(254,160,25,1))
}
/* red */
#bfTray .bfmini-piece[data-tint="3"]{
  filter:
    drop-shadow(0 0 3px rgb(255, 0, 0))
}
/* violet */
#bfTray .bfmini-piece[data-tint="4"]{
  filter:
    drop-shadow(0 0 3px rgba(122,92,255,1))
}
/* lime */
#bfTray .bfmini-piece[data-tint="5"]{
  filter:
    drop-shadow(0 0 3px rgba(51,255,0,1))
    
}

/* Pop + fade when the board resets */
@keyframes bfBoardPop {
  0%   { transform: scale(1);    opacity: 1; }
  50%  { transform: scale(1.10); opacity: .9; }
  100% { transform: scale(1);    opacity: 1; }
}
@keyframes bfResetCell {
  from { opacity: 1;   filter: brightness(1);   }
  to   { opacity: 0;   filter: brightness(1.6); }
}
.board.resetting{ animation: bfBoardPop 360ms ease-in-out; }
.board .cell.filled.reset-fade{ animation: bfResetCell 1000ms ease-out forwards; }

/* Transparent color-matched preview */
.board .cell.preview{
  background: var(--fill);        /* same gradient/colour as the piece */
  opacity: .35;                   /* make it see-through */
  outline: 1px dashed var(--stroke, rgba(255,255,255,.25));
  box-shadow: none;               /* optional: keep preview clean */
}

/* make preview/hover cells paint from the --fill variable */
.board .cell.preview,
.board .cell.hover-ok{
  background: var(--fill) !important; /* pull from JS-set variable */
  opacity: .35;                        /* ghosty */
  outline: 1px dashed var(--stroke, rgba(255,255,255,.25));
  border-radius:8px;
  box-shadow: 0 0 1px rgba(255, 255, 255, 0.35),
              inset 0 2px 0 rgba(255, 255, 255, 0.60),
              inset 0 -3px 0 rgba(0, 0, 0, 0.35); }
/* Lifted preview overlay that does NOT move the real cell */
.board .cell.hover-ok,
.board .cell.hover-bad { position: relative; pointer-events: none; }

.board .cell.hover-ok::after,
.board .cell.hover-bad::after{
  content: "";
  position: absolute;
  inset: 0;                    /* same size as the cell */
  border-radius: 8px;
  background: var(--fill, transparent);
  outline: 1px dashed var(--stroke, rgba(255,255,255,.25));
  opacity: .35;
  box-shadow: 0 0 1px rgba(255,255,255,.35),
              inset 0 2px 0 rgba(255,255,255,.60),
              inset 0 -3px 0 rgba(0,0,0,.35);  /* â† lift the PREVIEW (tweak value to taste) */
  pointer-events: none;          /* never block touches/mouse */
}

/* Force an explicit width even inside a flex row */
#homeOfflineBtn{
  display: inline-flex;              /* so width applies */
  justify-content: center;
  align-items: center;
  box-sizing: border-box;
  width: 280px;                      /* <- change me */
  min-width: 260px;
  flex: 0 0 320px;                   /* ignore flex auto-sizing */
}
/* Force an explicit width even inside a flex row */
#homeOnlineBtn{
  display: inline-flex;              /* so width applies */
  justify-content: center;
  align-items: center;
  box-sizing: border-box;
  width: 280px;                      /* <- change me */
  min-width: 260px;
  flex: 0 0 320px;                   /* ignore flex auto-sizing */
}
/* Force an explicit width even inside a flex row */
#homeThemeBtn{
  display: inline-flex;              /* so width applies */
  justify-content: center;
  align-items: center;
  box-sizing: border-box;
  width: 280px;                      /* <- change me */
  min-width: 260px;
  flex: 0 0 320px;                   /* ignore flex auto-sizing */
}

/* Disable all mouse/touch on tray pieces while autoplay is on */
.auto-play #bfTray .bfmini-piece{
  pointer-events: none;
  cursor: default;
  touch-action: none;
}
#bfTray .bfmini-piece{ pointer-events: none; cursor: default; touch-action: none; }

/* Prevent any inner spans/pseudo elements from grabbing the click */
#offline #classicBtn *, #offline #classicBtn::before, #offline #classicBtn::after,
#offline #tetrisBtn  *, #offline #tetrisBtn::before,  #offline #tetrisBtn::after,
#offline #versusBtn  *, #offline #versusBtn::before,  #offline #versusBtn::after{
  pointer-events: none !important;
}
/* MODE / second page only */
#offline{ position: relative; isolation: isolate; }

/* Let clicks pass through the tray + its slots on the Mode page */
#offline :is(#bfTray, #bfTrayHome),
#offline :is(#bfTray, #bfTrayHome) .slot,
#offline :is(#bfTray, #bfTrayHome) .bfmini-piece{
  pointer-events: none !important;   /* still visible; just not clickable */
  position: relative;
  z-index: 1;                        /* keep it below the buttons */
}

/* Ensure the three buttons sit above everything and are fully clickable */
#offline #classicBtn,
#offline #tetrisBtn,
#offline #versusBtn{
  position: relative !important;
  z-index: 1000 !important;
  pointer-events: auto !important;
  display: inline-flex !important;
  align-items: center; justify-content: center;
  line-height: normal !important;
  box-sizing: border-box;
}

/* Children/pseudo-elements of the buttons won't steal clicks */
#offline #classicBtn *, #offline #classicBtn::before, #offline #classicBtn::after,
#offline #tetrisBtn  *, #offline #tetrisBtn::before,  #offline #tetrisBtn::after,
#offline #versusBtn  *, #offline #versusBtn::before,  #offline #versusBtn::after{
  pointer-events: none !important;
}

/* === Consistent tray layout across devices (Mode/second page) === */
#offline .bfmini-tray{
  display: grid;
  grid-template-columns: repeat(3, minmax(0,1fr));
  gap: clamp(8px, 2vw, 18px);
  align-items: center;
  justify-items: center;
  max-width: min(560px, 92vw);
  margin: 12px auto 0;
  padding: 0 clamp(4px, 2vw, 12px);
  box-sizing: border-box;
}

/* each slot keeps a consistent box to center pieces in */
#offline .bfmini-tray .slot{
  display: grid;
  place-items: center;
  min-height: clamp(72px, 18vw, 120px);
}

/* pieces are built from cells, not scaled via transform */
#offline .bfmini-tray .bfmini-piece{
  /* cell size + gap are responsive; no transform-scaling needed */
  --cell: clamp(18px, 5.2vw, 28px);
  --gap:  clamp(4px, 1.2vw, 8px);
  display: grid;
  grid-auto-rows: var(--cell);
  gap: var(--gap);
  transform: none !important;   /* neutralize JS scaling differences */
}

/* each cell = square with your bevel; will be identical across DPRs */
#offline .bfmini-tray .bfmini-piece .cell{
  width: var(--cell);
  height: var(--cell);
  border-radius: 8px;
  box-shadow:
    0 0 1px rgba(255,255,255,.35),
    inset 0 2px 0 rgba(255,255,255,.6),
    inset 0 -3px 0 rgba(0,0,0,.35);
}

/* (optional) tighten spacing on very small phones */
@media (max-width: 380px){
  #offline .bfmini-tray{ gap: 10px; }
  #offline .bfmini-tray .slot{ min-height: 84px; }
}

/* Make the tray a 3-column grid with consistent gaps */
#bfTray{
  display: grid;
  grid-template-columns: repeat(3, minmax(0,1fr));
  gap: clamp(12px, 3vw, 24px);
  justify-items: center;   /* center within each column */
  align-items: start;
}

/* Each slot centers its child; no transforms needed */
#bfTray .slot{
  display: grid;
  place-items: center;
  min-height: clamp(72px, 18vw, 120px); /* keeps a nice box for the piece */
}

/* Neutralize any leftover translate/scale on home tray pieces */
#bfTray .bfmini-piece{
  transform: none !important;    /* prevent stacking with JS transforms */
  margin-top: -30px;             /* keep your vertical nudge, not with transform */
}

/* If you want left/center/right anchoring per slot (optional) */
#bfTray .slot[data-slot="0"]{ justify-self: start; }
#bfTray .slot[data-slot="1"]{ justify-self: center; }
#bfTray .slot[data-slot="2"]{ justify-self: end; }


/* MODE (second page) â€” force a predictable tray layout */
#offline :is(#bfTray, #bfTrayHome){
  display: grid !important;
  grid-template-columns: repeat(3, minmax(0,1fr)) !important;
  /* â† CHANGE THIS to adjust spacing between the three pieces */
  gap: clamp(12px, 3vw, 28px) !important;
  justify-items: center !important;
  align-items: start !important;
}

/* Center each slotâ€™s content; provide a consistent box height */
#offline :is(#bfTray, #bfTrayHome) .slot{
  display: grid !important;
  place-items: center !important;
  min-height: clamp(80px, 18vw, 120px) !important;
}

/* Neutralize any translate/scale applied by earlier CSS/JS on these pieces */
#offline :is(#bfTray, #bfTrayHome) .bfmini-piece{
  transform: none !important;          /* kills translate/scale drift */
  /* vertical tweak instead of translateY: change this if needed */
  margin-top: -30px !important;
}

/* (optional) control left/center/right anchoring per column */
#offline :is(#bfTray, #bfTrayHome) .slot[data-slot="0"]{ justify-self: start !important; }
#offline :is(#bfTray, #bfTrayHome) .slot[data-slot="1"]{ justify-self: center !important; }
#offline :is(#bfTray, #bfTrayHome) .slot[data-slot="2"]{ justify-self: end !important; }

/* Cell size + internal gap inside each piece (keeps shape proportions) */
#offline :is(#bfTray, #bfTrayHome) .bfmini-piece{ --cell: clamp(1px, 5.2vw, 8px); --gap: clamp(40px, 1.2vw, 80px); }
#offline :is(#bfTray, #bfTrayHome) .bfmini-piece .cell{
  width: var(--cell) !important;
  height: var(--cell) !important;
  border-radius: 8px;
}

/* MODE page tray: 3 equal columns + adjustable spacing */
#home #bfTray{
  display: grid;
  grid-template-columns: repeat(3, minmax(0,1fr));
  gap: 250px;                  /* â† change this to move pieces apart */
  justify-items: center;
  align-items: start;
}

/* each slot centers its child; consistent height so it doesn't jump */
#home #bfTray .slot{
  display: grid;
  place-items: center;
  min-height: 110px;          /* tweak if you want more/less height */
}

/* optional: anchor left/center/right by column */
#home #bfTray .slot[data-slot="0"]{ justify-self: start; }
#home #bfTray .slot[data-slot="1"]{ justify-self: center; }
#home #bfTray .slot[data-slot="2"]{ justify-self: end; }

/* --- Mode tray: keep 3 fixed columns so positions never shift --- */
#home #bfTray,
#home #bfTrayHome{
  /* fixed-width tracks; they don't shrink when a slot is empty */
  --slot-w: clamp(96px, 22vw, 140px);     /* <-- adjust width per column */
  display: grid !important;
  grid-template-columns: var(--slot-w) var(--slot-w) var(--slot-w) !important;
  justify-content: center !important;     /* group centered as a whole */
  column-gap: 40px !important;            /* adjust spacing between columns */
  align-items: start !important;
}

/* each slot uses the same fixed width box */
#home #bfTray .slot,
#home #bfTrayHome .slot{
  width: var(--slot-w) !important;
  display: grid !important;
  place-items: center !important;
  min-height: clamp(80px, 18vw, 120px) !important;
}

/* neutralize any translate/scale that fights layout on the mode page tray */
#home #bfTray .bfmini-piece,
#home #bfTrayHome .bfmini-piece{
  transform: none !important;
  margin-top: -30px;                              /* vertical tweak if you want */
}

/* Lock page scrolling & overscroll bounce */
html, body {
  height: 100%;
  overflow: hidden;              /* no scrollbars */
  overscroll-behavior: none;     /* no pull-to-refresh/bounce */
}

/* Your app wrapper (adjust selector to your root if different) */
#home, #game { touch-action: none; }

/* Classic grid-only screen layout */
#screen-classic-grid{
  position: fixed;
  inset: 0;
  z-index: 20;

  /* This is the overlay background */
  background: radial-gradient(circle farthest-corner at 50% 50%, #010724 70%, #3A5292 150%);
  background-size: 100vw 100vh;
  background-repeat: no-repeat;
  background-position: center;
  /* Center grid + tray vertically */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 24px;
}

/* Frame similar to your mode/demo board */
/* Classic grid wrapper – no extra panel, just centering */
.classic-grid-wrap{
  width: min(92vw, 560px);
  max-width: 560px;

  /* just use it as a centering box */
  display: flex;
  align-items: center;
  justify-content: center;

  padding: 0;
  border-radius: 0;
  background: transparent;
  box-shadow: none;
}


/* The 8Ã—8 grid */
.classic-grid{
  width: 100%; height: 100%;
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);
  gap: 6px;
  padding: 12px;
  border-radius: 16px;
  background: var(--panel, #101726);
  box-shadow: 0 0 0 1px rgba(255,255,255,.04) inset,
              0 0 32px -8px rgba(0,255,200,.18) inset;
}

/* Empty cells (same beveled/soft look as your mode grid) */
.classic-grid .cg{
  border-radius: 10px;
  background:
    radial-gradient(140% 140% at 30% 30%, rgba(255,255,255,.06), transparent 55%),
    color-mix(in oklab, var(--panel, #0f1626) 85%, black);
  box-shadow:
    0 1px 0 rgba(255,255,255,.04) inset,
    0 -1px 0 rgba(0,0,0,.25) inset;
}

/* TEMP: hide Mode/Home during dev */



/* Constrain mini demo children to the Home stage */
#homeMiniDemo { position: relative; }

#homeMiniCanvas {
  position: absolute;
  inset: 0;
  pointer-events: none;
  display: block;
}

/* Center by default (already) */
#screen-classic-grid { display:grid; place-items:center; }


/* Move the whole grid vertically (negative = up, positive = down) */
#classicGridWrap { 
  align-self: center;           /* start | center | end */
  justify-self: center;         /* start | center | end */
  transform: translate(0, 45px);  /* X, Y â€” e.g., up 24px */
}

/* Examples:
   Move left:  transform: translate(-20px, 0);
   Move right: transform: translate(20px, 0);
   Pin to top center instead of center: */
#screen-classic-grid.pin-top { place-items: start center; }

/* If you want fixed coordinates instead of centering, do this instead: */
/*
#screen-classic-grid { position: relative; }
#classicGridWrap {
  position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
}
*/

/* Container layout for the 3 choices on the Classic page */


/* Make the Classic screen center its column wrapper */
#screen-classic-grid { display:grid; place-items:center; }

/* Classic tray layout (matches Mode tray) */
#screen-classic-grid #bfTrayClassic{
  --slot-w: clamp(96px, 22vw, 140px);
  display: grid !important;
  grid-template-columns: var(--slot-w) var(--slot-w) var(--slot-w) !important;
  justify-content: center !important;
  column-gap: 40px !important;
  align-items: start !important;
  margin-top: 0; /* the column wrapper already has gap */
}

/* Center the mini piece inside each slot; cancel demo transforms */
#screen-classic-grid #bfTrayClassic .bfmini-piece{
  display: grid;
  place-items: center;
  transform: none !important;
  margin-top: -30px;
}

/* Classic tray: keep centering box but no card look */
#screen-classic-grid #bfTrayClassic .slot{
  width: var(--slot-w);
  min-height: 84px;
  display: grid;
  place-items: center;
  background: transparent !important;
  box-shadow: none !important;
}

/* Classic tray: use the SAME inner spacing as Mode */
#screen-classic-grid #bfTrayClassic .bfmini-piece{
  display: grid;
  place-items: center;
  gap: 2px !important;        /* <- match your Mode value */
  transform: none !important;
  margin-top: -30px;         /* same vertical nudge as Mode */
}

/* Classic tray: keep mini cell size identical to Mode */
#screen-classic-grid #bfTrayClassic .bfmini-piece .cell{
  width:  calc(var(--cell, 40) * 0.5px) !important;
  height: calc(var(--cell, 40) * 0.5px) !important;
}

/* Classic tray â€“ corner radius of each little square */
#screen-classic-grid #bfTrayClassic .bfmini-piece .cell{
  border-radius: 4px !important;   /* â† set your number here */
}

/* Classic tray: move each piece individually */
#screen-classic-grid #bfTrayClassic .slot:nth-child(1) .bfmini-piece { 
  transform: translate(65px, 6px) !important;   /* left, down */
}

#screen-classic-grid #bfTrayClassic .slot:nth-child(2) .bfmini-piece { 
  transform: translate(0, 6px) !important;        /* centered (baseline) */
}

#screen-classic-grid #bfTrayClassic .slot:nth-child(3) .bfmini-piece { 
  transform: translate(-65px, 6px) !important;  /* right, up */
}

/* Force pointer events on Classic tray only */
#screen-classic-grid #bfTrayClassic,
#screen-classic-grid #bfTrayClassic *{
  pointer-events: auto !important;
}

/* Lock Classic board to 8Ã—8 tracks so it never visually shrinks */
#screen-classic-grid #classicBoard{
  --cols: 8;
  --rows: 8;
  display: grid;
  grid-template-columns: repeat(var(--cols), 1fr);
  grid-template-rows: repeat(var(--rows), 1fr); /* â† key line */
}

/* Make sure clearing cells still occupy space (no collapse) */
#screen-classic-grid .cell.clearing{
  display: block !important;
  visibility: visible !important;
  /* keep layout even if you animate opacity/transform */
}

/* Classic drag ghost: follows the finger, sized to grid cells */
#screen-classic-grid .drag-ghost{
  position: fixed;
  left: 0; top: 0;
  transform: translate(-50%,-50%);
  z-index: 9999;
  pointer-events: none;
  display: grid;
  gap: var(--gap, 6px);
}
#screen-classic-grid .drag-ghost .ghost-cell{
  width: var(--cell);
  height: var(--cell);
  border-radius: 8px;
  background: var(--fill, #333);
  box-shadow:
    0 0 1px rgba(255,255,255,.35),
    inset 0 2px 0 rgba(255,255,255,.60),
    inset 0 -3px 0 rgba(0,0,0,.35);
}
body.classic-mode #tetrisControls {
  display: none !important;
}
</style>
</head>


<!-- Background demo -->
<!--<div id="demoStage" class="stage">
  <div id="demoWrap" class="board-wrap">
    <div id="demoBoard" class="board"></div>
    <div id="demoPreview" class="preview-layer"></div>
    <div id="demoScore" class="score-banner">0</div>
    <div id="demoTray" class="tray"></div>
  </div>
</div>-->

<!-- Home + Menus -->
<div id="home" class="app center">
  <h1>Mode</h1>
  <!-- Mini background gameplay (HOME) -->
<div id="homeMiniDemo" class="mini-stage" aria-hidden="true">
  <!-- real board skin (identical look to Classic) -->
  <div id="miniBoardClone" class="board"></div>
  <!-- transparent overlay for the falling block -->
  <canvas id="homeMiniCanvas"></canvas>
</div>
<div id="bfTray" class="bfmini-tray" style="pointer-events:none; z-index:1; position:relative;">
  <div class="slot" data-slot="0"></div>
  <div class="slot" data-slot="1"></div>
  <div class="slot" data-slot="2"></div>
</div>






  <!-- Positioning wrapper for first-page buttons -->
  <div id="homeLayout" class="home-layout">
    <button id="homeOfflineBtn" onclick="openClassicGrid()">Classic</button>
    <button id="homeOnlineBtn" onclick="startMode('tetris')">Tetris</button>
    <button id="homeThemeBtn"   onclick="toggleTheme()">Versus</button>
    <!-- inside: <div id="homeLayout" class="home-layout"> ... -->
<button id="homeSettingsBtn" class="icon-btn" onclick="openSettings()" aria-label="Settings" title="Settings">
  <img
    src="icons/settings.png"
    alt=""
    width="40" height="40"
    decoding="async" loading="eager"
    draggable="false"
  />
</button>

  </div>
</div>

<!-- Overlays -->
<div id="overlay" class="hidden">
  <h2>Game Over</h2>
  <button onclick="retryGame()">Retry</button>
  <button onclick="goHome()">Home</button>
</div>

<div id="backMenu" class="hidden">
  <h2>Pause</h2>
  <button onclick="(hideBackMenu(),goHome())">Home</button>
  <button id="ghostToggle" onclick="toggleGhostMode()">Ghost: Outline</button>
  <button onclick="(hideBackMenu(),retryGame())">Restart</button>
  <button onclick="hideBackMenu()">Cancel</button>
</div>

<!-- Game -->
<div id="game" class="app center hidden">
  <div id="score">0</div>
  <div id="hudLayer">
    <div id="comboBanner">Combo x1.00</div>
  </div>
  <div id="boardWrap" class="board-wrap">
    <div id="board" class="board"></div>
    
    <div id="preview" class="preview-layer"></div>
 <div id="bfTray" class="bfmini-tray">
  <div class="slot" data-slot="0"></div>
  <div class="slot" data-slot="1"></div>
  <div class="slot" data-slot="2"></div>
</div>
<!-- Classic grid-only screen -->
<div id="screen-classic-grid" class="app hidden">
  <div class="classic-grid-wrap" id="classicGridWrap">
    <!-- 8×8 board; JS will fill in .cell divs -->
    <div id="classicBoard" class="board"></div>
  </div>

  <!-- Classic tray under the grid -->
  <div id="bfTrayClassic" class="bfmini-tray">
    <div class="slot" data-slot="0"></div>
    <div class="slot" data-slot="1"></div>
    <div class="slot" data-slot="2"></div>
  </div>
</div>


  </div>
  <div id="tray"></div>
  <div id="tetrisControls">
    <button onclick="tKey('Left')">â—€</button>
    <button onclick="tKey('Rotate')">âŸ²</button>
    <button onclick="tKey('Right')">â–¶</button>
    <button onclick="tKey('Down')">â–¼</button>
    <button onclick="tKey('Drop')">â¤“</button>
  </div>
  <button onclick="showBackMenu()">â¬… Back</button>
</div>

<!-- All scripts moved to separate files - see bottom of file -->
<!-- ===== NEON HOME OVERLAY (first screen) ===== -->
<!-- ===== NEON PORTRAIT HOME (exact mock) ===== -->
<div id="homeOverlay" aria-hidden="true">
  <div class="hf-phone">
    <div class="hf-board">
      <div class="hf-sparkles" aria-hidden="true"></div>

      <h1 class="hf-title">
        <span>BLOCK</span><br><span>FORGE</span>
      </h1>

      <!-- mini 8Ã—12 grid + decorative blocks (filled by JS) -->
      <div id="hfGrid" class="hf-grid" aria-hidden="true"></div>
    </div>

    <button id="hfPlay" class="hf-cta">PLAY</button>

    <div class="hf-tray">
      <div class="hf-card"><div class="hf-piece p1"></div></div>
      <div class="hf-card"><div class="hf-piece p2"></div></div>
      <div class="hf-card"><div class="hf-piece p3"></div></div>
    </div>
  </div>
</div>


<!-- Update prompt toast -->
<div id="updateToast" role="status" aria-live="polite" class="hidden">
  <span>New version available</span>
  <button id="updateLaterBtn" type="button">Later</button>
  <button id="updateNowBtn" class="primary" type="button">Refresh</button>
</div>
<script>
(() => {
  function wrapHome(){
    const home = document.getElementById('homeOverlay');
    if (!home) return console.warn('fitstage: #homeOverlay not found');

    // Already wrapped? exit.
    if (home.closest('.fitstage')) return;

    // Create wrappers
    const stage = document.createElement('div');
    stage.className = 'fitstage';
    const box = document.createElement('div');
    box.className = 'fitbox';

    // Insert stage where #homeOverlay currently sits
    const parent = home.parentNode;
    parent.insertBefore(stage, home);
    stage.appendChild(box);
    box.appendChild(home); // move your existing overlay inside the fitbox
  }

  // run after DOM is parsed
  (document.readyState === 'loading')
    ? document.addEventListener('DOMContentLoaded', wrapHome, { once:true })
    : wrapHome();
})();


</script>
<script>
(function(){
  function setVH(){
    var vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--app-h', (vh*100) + 'px');
  }
  setVH();
  addEventListener('resize', setVH);
  addEventListener('orientationchange', setVH);
})();
</script>
<!-- Put this just above </body> -->
<script>
  // Make sure a global function exists for the Settings button
  window.openSettings = window.openSettings || function () {
    alert('6 7');
  };
</script>
<script>
(function(){
  const wrap   = document.getElementById('homeMiniDemo');
  const mini   = document.getElementById('miniBoardClone');
  const cvs    = document.getElementById('homeMiniCanvas');
  if (!wrap || !mini || !cvs) return;

  const ctx = cvs.getContext('2d');

  // 1) Copy skin from your real board if we can find one
  (function copySkin(){
    const real = document.querySelector('#game .board, .app .board'); // try to find any live board
    if (!real) return;
    const cs = getComputedStyle(real);
    ['background','boxShadow','borderRadius'].forEach(p=> mini.style[p] = cs[p]);
    ['--cell','--gap','--pad','--cols'].forEach(v=>{
      const val = cs.getPropertyValue(v);
      if (val) mini.style.setProperty(v, val.trim());
    });
  })();

  // 2) Build a DOM grid that matches your board's shape
  const COLS = parseInt(getComputedStyle(mini).getPropertyValue('--cols')) || 8;
  const GAP  = parseInt(getComputedStyle(mini).getPropertyValue('--gap'))  || 6;
  const PAD  = parseInt(getComputedStyle(mini).getPropertyValue('--pad'))  || 8;

  mini.style.display = 'grid';
  mini.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
  mini.style.gap = `${GAP}px`;
  mini.style.padding = `${PAD}px`;

  // create cells so your .board/.cell CSS renders identically to Classic
  const frag = document.createDocumentFragment();
  const cells = COLS * COLS;  // square banner
  for (let i=0; i<cells; i++){
    const d = document.createElement('div');
    d.className = 'cell';
    frag.appendChild(d);
  }
  mini.innerHTML = ''; mini.appendChild(frag);

  // 3) Fit the canvas and animate a ghost piece aligned to the DOM grid
  let W=0,H=0, cellPx=0, raf=null;
  const fall = { x: 0, y: -2.5, speed: 0.016 };

  function readCellSize(){
    const one = mini.querySelector('.cell');
    if (!one) return 40;
    const cs = getComputedStyle(one);
    return Math.round(parseFloat(cs.width));
  }

  function fit(){
    const r = wrap.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    cvs.width  = Math.max(320, Math.floor(r.width  * dpr));
    cvs.height = Math.max(160, Math.floor(r.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    W = r.width; H = r.height;
    cellPx = readCellSize();
  }

  function gridOrigin(){
    const pad = PAD;
    const gridW = mini.clientWidth  - pad*2;
    const gridH = mini.clientHeight - pad*2;
    const startX = Math.round((W - gridW)/2 + pad);
    const startY = Math.round((H - gridH)/2 + pad);
    return { startX, startY };
  }

  function drawGhost(origin){
    const { startX, startY } = origin;
    const gap = GAP;
    const px = startX + fall.x*(cellPx+gap);
    const py = startY + fall.y*(cellPx+gap);

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (let r=0; r<2; r++){
      for (let c=0; c<2; c++){
        const fx = px + c*(cellPx+gap);
        const fy = py + r*(cellPx+gap);
        ctx.fillStyle   = 'rgba(57,255,20,0.12)';
        ctx.strokeStyle = 'rgba(57,255,20,0.20)';
        ctx.lineWidth = 2;
        ctx.fillRect(fx, fy, cellPx, cellPx);
        ctx.strokeRect(fx+1, fy+1, cellPx-2, cellPx-2);
      }
    }
    ctx.restore();

    // update fall
    fall.y += fall.speed * (H/220);
    if (startY + (fall.y+2)*(cellPx+gap) > startY + COLS*(cellPx+gap)){
      fall.y = -2.5;
      fall.x = Math.floor(Math.random()*(COLS-1));
    }
  }

  function loop(){
    ctx.clearRect(0,0,W,H);   // DOM renders the grid; canvas draws only the ghost
    drawGhost(gridOrigin());
    raf = requestAnimationFrame(loop);
  }

  new ResizeObserver(fit).observe(wrap);
  fit(); loop();

  // Pause when Home is hidden
  const mo = new MutationObserver(()=>{
    const home = document.getElementById('home');
    const hidden = home?.classList.contains('hidden');
    if (hidden && raf){ cancelAnimationFrame(raf); raf=null; }
    else if (!hidden && !raf){ fit(); loop(); }
  });
  mo.observe(document.body, {subtree:true, attributes:true, attributeFilter:['class']});
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const board = document.getElementById('miniBoardClone');
  const tray  = document.getElementById('bfTray');
  // Build slots if not present in the HTML
// Build 3 fixed slots if they aren't in the HTML
(function ensureTraySlots(){
  if (!tray) return;
  if (!tray.querySelector('.slot')){
    for (let i = 0; i < 3; i++){
      const s = document.createElement('div');
      s.className = 'slot';
      s.dataset.slot = String(i);
      tray.appendChild(s);
    }
  }
})();


  if (!board || !tray) return;

  // --- Z-INDEX SAFETY: grid above tray so placed cells show ---
  board.style.position = 'relative';
  board.style.zIndex = '3';
  const banner = document.getElementById('homeMiniDemo');
  if (banner) { banner.style.position = 'relative'; banner.style.zIndex = '2'; }
  tray.style.position = 'relative';
  tray.style.zIndex = '1';

  // --- Ensure grid cells exist (some older code used to create them) ---
  function ensureGridCells(){
    const current = board.querySelectorAll('.cell');
    if (current.length) return Array.from(current);

    const cs   = getComputedStyle(board);
    const COLS = parseInt(cs.getPropertyValue('--cols')) || 8;
    const ROWS = parseInt(cs.getPropertyValue('--rows')) || COLS;
  
    board.style.display = 'grid';
    board.style.gridTemplateColumns = `repeat(${COLS}, calc(var(--cell,40) * 1px))`;

    const frag = document.createDocumentFragment();
    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const d = document.createElement('div');
        d.className = 'cell';
        d.dataset.r = r; d.dataset.c = c;
        frag.appendChild(d);
      }
    }
    board.appendChild(frag);
    return Array.from(board.querySelectorAll('.cell'));
  }

  const cellEls = ensureGridCells();
  if (!cellEls.length) return;

  // --- Board metrics from the REAL DOM ---
  const cs   = getComputedStyle(board);
  const GAP  = parseFloat(cs.getPropertyValue('gap'))     || 6;
  const PAD  = parseFloat(cs.getPropertyValue('padding')) || 8;
  const COLS = parseInt(cs.getPropertyValue('--cols'))    || Math.round(Math.sqrt(cellEls.length));
  const ROWS = Math.round(cellEls.length / COLS);
  const CELL = (()=>{ const one = cellEls[0]; return one ? parseFloat(getComputedStyle(one).width) : 38; })();
  const idx  = (r,c)=> r*COLS + c;

  // This DOMContentLoaded block continues in mode.js
  // All game logic has been moved to separate JS files
});
</script>

<script>
function show(el){ if(el){ el.classList.remove('hidden'); el.setAttribute('aria-hidden','false'); el.style.display='block'; el.style.display = el.id === 'screen-classic-grid' ? 'grid' : 'block';} }
function hide(el){ if(el){ el.classList.add('hidden');  el.setAttribute('aria-hidden','true');  el.style.display='none'; } }
</script>

<script>
window.clearFullLinesClassic = function (board, cells, S, ROWS, COLS, idx){
  const fullRows=[], fullCols=[];
  for (let r=0;r<ROWS;r++) if (S[r].every(v=>v===1)) fullRows.push(r);
  for (let c=0;c<COLS;c++){
    let ok=true; for (let r=0;r<ROWS;r++){ if (S[r][c]===0){ ok=false; break; } }
    if (ok) fullCols.push(c);
  }
  if (!fullRows.length && !fullCols.length) return;

  // Visual pulse (keeps cells in the grid)
  [...fullRows, ...fullCols].forEach(() => {/* optional: you can add a class for FX if you want */});

  // After short delay, just unfill cells â€” DO NOT remove nodes
  setTimeout(()=>{
    fullRows.forEach(r=>{
      for (let c=0;c<COLS;c++){
        const el = cells[idx(r,c)]; if (!el) continue;
        el.classList.remove('filled','preview','hover-ok','hover-bad','clearing');
        el.style.removeProperty('--fill'); el.style.removeProperty('--stroke');
        el.style.removeProperty('--glow'); el.style.removeProperty('--glow-inset');
      }
    });
    fullCols.forEach(c=>{
      for (let r=0;r<ROWS;r++){
        const el = cells[idx(r,c)]; if (!el) continue;
        el.classList.remove('filled','preview','hover-ok','hover-bad','clearing');
        el.style.removeProperty('--fill'); el.style.removeProperty('--stroke');
        el.style.removeProperty('--glow'); el.style.removeProperty('--glow-inset');
      }
    });
  }, 240);
};
</script>

<!-- Scripts moved to separate files -->
<script src="init.js"></script>
<script src="shared.js"></script>
<script src="home.js"></script>
<script src="mode.js"></script>
<script src="classic.js"></script>
<script src="tetris.js"></script>

</body>
</html>
