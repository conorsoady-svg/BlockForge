<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="format-detection" content="telephone=no" />
<title>Block Forge â€” Full Game (Neon, Mobile, Demo AI)</title>
 <link rel="manifest" href="manifest.webmanifest?v=4">
<link rel="icon" type="image/png" sizes="192x192" href="icons/192x192.png">
<link rel="apple-touch-icon" href="icons/192x192.png">
<meta name="theme-color" content="#0c1226">


<style>
:root{--cell:40;--gap:2;--pad:4;--clear-ms:420;--cols:8}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;-webkit-text-size-adjust:100%}
body{margin:0;background:radial-gradient(1200px 800px at 20% 0%,#0b1022,#0c1226 50%,#0a0f1f);color:#e8ebf3;text-align:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overscroll-behavior-y:none;-webkit-user-select:none;user-select:none}
.hidden{display:none!important}

/* --- Update toast (PWA) --- */
#updateToast {
  position: fixed;
  left: 50%;
  bottom: 16px;
  transform: translateX(-50%) translateY(20px);
  background: rgba(12,18,38,.92);
  color: #e8ebf3;
  border-radius: 12px;
  padding: 10px 14px;
  box-shadow: 0 10px 24px rgba(0,0,0,.35), 0 0 14px rgba(57,255,20,.25);
  display: none;
  z-index: 9999;
  font-weight: 700;
  letter-spacing: .2px;
}
#updateToast.show { display: flex; gap: 10px; align-items: center; }
#updateToast button {
  margin: 0;
  padding: 6px 10px;
  font-size: 14px;
  border: none;
  border-radius: 10px;
  background: #111827;
  color: #00fff2;
  cursor: pointer;
}
#updateToast button.primary { background:#00ffea; color:#0b1022; font-weight:900; }
#updateToast button:hover { background: #1f2937; box-shadow: 0 0 12px rgb(0, 247, 255); }
#updateToast button:active { transform: translateY(1px); }





/* UI */
button{margin:6px;padding:10px 20px;font-size:16px;border:none;border-radius:12px;background:#111827;color:#00ffea;cursor:pointer;box-shadow:0 0 8px rgb(0, 255, 234);transition:background .2s,box-shadow .2s,transform .06s}
button:active{transform:translateY(1px)}
.app{
  width: 100%;
  max-width: min(560px, 92vw);
  margin: 0 auto;
  padding: 16px;
  position: relative;
  z-index: 1;
}


.sub{opacity:.8;margin-bottom:8px}

/* Boards */
.board-wrap{position:relative;display:inline-block}
.board{display:grid;grid-template-columns:repeat(var(--cols),calc(var(--cell)*1px));gap:calc(var(--gap)*1px);background:#0e1324;padding:calc(var(--pad)*1px);border-radius:16px;box-shadow:0 0 28px rgba(0,255,255,.25),0 10px 28px rgba(0,0,0,.45);position:relative;width:calc(var(--cols) * var(--cell) * 1px + (var(--cols) - 1) * var(--gap) * 1px + 2 * var(--pad) * 1px);overflow:hidden}
.cell{width:calc(var(--cell)*1px);height:calc(var(--cell)*1px);background:rgba(255,255,255,0.10);border-radius:10px;position:relative;overflow:hidden;will-change:transform,opacity}
.block{box-shadow:inset 0 2px 0 rgba(255,255,255,.35),inset 0 -3px 0 rgba(0,0,0,.35),0 0 12px rgba(0,255,255,.35);background-image:radial-gradient(120% 90% at 20% 10%, rgba(255,255,255,.35), rgba(255,255,255,0) 55%),linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.12))}



/* Animations */
@keyframes pop{0%{transform:scale(1)}50%{transform:scale(1.16)}100%{transform:scale(1)}}
@keyframes waveIn{0%{transform:scale(.7);opacity:.15}45%{transform:scale(1.15);opacity:1}100%{transform:scale(1);opacity:1}}
@keyframes waveOut{0%{transform:scale(1);opacity:1}60%{transform:scale(1.08)}100%{transform:scale(.85);opacity:.05}}
@keyframes jumpOut{0%{transform:scale(1)}55%{transform:scale(1.24)}100%{transform:scale(1)}}
@keyframes clearPulse{0%{transform:scale(1);filter:brightness(1);opacity:1}40%{transform:scale(1.06);filter:brightness(1.6)}70%{transform:scale(1)}100%{opacity:0;transform:scale(0.88)}}
@keyframes sweepH{0%{left:-120%}100%{left:120%}}
@keyframes sweepV{0%{top:-120%}100%{top:120%}}
.clearing{animation:clearPulse calc(var(--clear-ms) * 1ms) ease-in forwards;animation-delay:var(--cDelay,0ms);position:relative}
.clearing::after{content:"";position:absolute;inset:-40% -10%;pointer-events:none;background:linear-gradient(120deg, rgba(255,255,255,0), rgba(255,255,255,.9), rgba(255,255,255,0));opacity:.7}
.clearing.row::after{top:50%;height:40%;transform:translateY(-50%);left:-120%;animation:sweepH calc(var(--clear-ms) * 1ms) ease-out forwards;animation-delay:var(--cDelay,0ms)}
.clearing.col::after{left:50%;width:40%;transform:translateX(-50%);top:-120%;animation:sweepV calc(var(--clear-ms) * 1ms) ease-out forwards;animation-delay:var(--cDelay,0ms)}

/* Preview */
.preview-layer{position:absolute;left:0;top:0;pointer-events:none}
.preview-block{width:calc(var(--cell)*1px);height:calc(var(--cell)*1px);border-radius:10px;position:absolute;opacity:.6;box-shadow:0 0 12px rgba(0,255,170,.45);outline:2px dashed rgba(255,255,255,.25);outline-offset:-3px}
.preview-layer.valid .preview-block{box-shadow:0 0 0 2px rgba(0,255,170,.85),0 0 12px rgba(0,255,170,.6)}
.preview-layer.invalid .preview-block{box-shadow:0 0 0 2px rgba(255,0,120,.85),0 0 12px rgba(255,255,255,.6)}

/* Tray */
#tray{display:grid;grid-template-columns:repeat(3,max-content);gap:16px;justify-content:center;margin:14px auto 8px}
.piece.slot{display:flex;align-items:center;justify-content:center;background:transparent;border-radius:0;padding:0;min-width:auto;min-height:auto;box-shadow:none}
#tray .placeholder{opacity:.25}

/* Overlays */
#overlay,#backMenu{position:fixed;inset:0;background:rgba(0,0,0,.6);display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:5}
#overlay.hidden,#backMenu.hidden{display:none!important}

/* Game container */
#game{position:relative;padding-top:clamp(28px,6vh,60px)}

/* Tetris: square corners only in tetris mode */
.tetris .cell{border-radius:3px}
.tetris .preview-block{border-radius:3px}

/* Keep the home/background demo normal-sized */
.stage .board{--cell:40 !important}

/* On-screen Tetris controls: responsive */
#tetrisControls button{
  min-width:clamp(44px,8vw,64px);
  padding:clamp(6px,1.3vh,10px) clamp(10px,2.2vw,16px);
  font-size:clamp(12px,1.8vh,16px);
}

#score{position:absolute;top:6px;left:50%;transform:translateX(-50%);font-size:32px;color:#39ff14;text-shadow:0 0 8px rgba(57,255,20,.8)}

/* Background demo stage */
.stage{position:fixed;inset:0;display:flex;align-items:flex-start;justify-content:center;pointer-events:none;z-index:0;opacity:.45;filter:saturate(1.08) brightness(1.06)}
.stage .board-wrap{position:relative;margin-top:220px}
.stage .board{--cols:8;transform:scale(.9);overflow:hidden;width:calc(8 * var(--cell) * 1px + 7 * var(--gap) * 1px + 2 * var(--pad) * 1px)}
.stage .score-banner{position:absolute;top:-40px;left:50%;transform:translateX(-50%);font-weight:900;font-size:28px;background:rgba(0,0,0,.35);padding:6px 12px;border-radius:12px;white-space:nowrap}
.stage .tray{display:grid;grid-template-columns:repeat(3,max-content);gap:12px;justify-content:center;margin-top:10px}
.stage .tray .placeholder{opacity:.25}
@keyframes demoDrag{0%{transform:translateY(90px) scale(.92);opacity:0}60%{opacity:.7}100%{transform:translateY(0) scale(1);opacity:.6}}

/* Touch */
#board,#boardWrap,.piece.slot,.preview-layer{touch-action:none}

/* --- HUD / feedback --- */
#hudLayer{position:absolute; inset:0; pointer-events:none; z-index:4; display:flex; align-items:flex-start; justify-content:center;}
#comboBanner{position:absolute; top:44px; left:50%; transform:translateX(-50%); padding:6px 12px; border-radius:12px; background:rgba(0,0,0,.45); font-weight:800; letter-spacing:.5px; box-shadow:0 0 14px rgba(57,255,20,.35); opacity:0; transition:opacity .18s, transform .18s;}
#comboBanner.show{ opacity:1; transform:translateX(-50%) translateY(0) scale(1); }
#comboBanner.bump{ animation:comboBump .25s ease; }
@keyframes comboBump{0%{ transform:translateX(-50%) scale(.92);}60%{ transform:translateX(-50%) scale(1.08);}100%{ transform:translateX(-50%) scale(1);}}
.score-pulse{ animation:scorePulse .22s ease; }
@keyframes scorePulse{0%{ transform:translateX(-50%) scale(1); filter:brightness(1);}50%{ transform:translateX(-50%) scale(1.18); filter:brightness(1.4);}100%{ transform:translateX(-50%) scale(1); filter:brightness(1);}}
.toast{position:absolute; top:86px; left:50%; transform:translateX(-50%); font-weight:800; padding:4px 10px; border-radius:10px; background:rgba(12,18,38,.75); box-shadow:0 6px 16px rgba(0,0,0,.35); opacity:0; animation:toastRise .7s ease forwards;}
@keyframes toastRise{0%{ transform:translate(-50%, 8px) scale(.9); opacity:0; }20%{ opacity:1; }100%{ transform:translate(-50%,-20px) scale(1.0); opacity:0; }}

/* Floating points for placements/clears */
.float-score{position:absolute; top:86px; left:50%; transform:translateX(-50%) translateY(6px) scale(.9); font-weight:900; padding:2px 8px; border-radius:10px; background:rgba(12,18,38,.65); box-shadow:0 6px 16px rgba(0,0,0,.35); opacity:0; animation:floatUp .8s ease-out forwards; pointer-events:none;}
@keyframes floatUp{0%{ transform:translateX(-50%) translateY(6px)   scale(.9);  opacity:0; }20%{ opacity:1; }100%{ transform:translateX(-50%) translateY(-26px) scale(1.0); opacity:0; }}

/* Make combo banner flare when level increases */
#comboBanner.levelUp{ animation:comboBump .25s ease, comboGlow .8s ease; }
@keyframes comboGlow{0%{ box-shadow:0 0 0 rgba(57,255,20,0);}40%{ box-shadow:0 0 20px rgba(57,255,20,.8);}100%{ box-shadow:0 0 0 rgba(57,255,20,0);}}

/* Make sure foreground UI is always clickable on mobile */
.stage{ z-index:0 !important; pointer-events:none !important; }
.app{ position:relative; z-index:2 !important; }
#home button, #offline button, #online button, #game button{ pointer-events:auto; }

/* Safety: if any full-screen layer accidentally shows, force it behind */
#overlay.hidden, #backMenu.hidden{ display:none !important; }
#overlay, #backMenu{ z-index: 5; }  /* higher than .app only when visible */

/* Tetris on-screen controls (mobile) */
#tetrisControls{display:none;gap:8px;justify-content:center;margin:8px 0}
#tetrisControls button{min-width:64px}

/* ===== Neon portrait home â€” reference match ===== */
:root{ --hf-green:#65ff57; --hf-cyan1:#7bf5ff; --hf-cyan2:#22d6ff; }

#homeOverlay{
  position:fixed; inset:0; z-index:10000;
  display:none; align-items:flex-start; justify-content:center;
  min-height:100svh; height:100dvh;
  --homeOffset: clamp(28px, 8svh, 120px); /* push card down */
  background:#000D27;
  backdrop-filter: blur(6px);
  padding:
    max(10px, env(safe-area-inset-top))
    max(15px, env(safe-area-inset-right))
    max(16px, env(safe-area-inset-bottom))
    max(15px, env(safe-area-inset-left));
}
#homeOverlay.show{ display:flex; }

/* phone card */
.hf-phone{
  width:clamp(450px, 33vw, 420px);
  display:flex; flex-direction:column; align-items:center; gap:16px;
  margin-top: var(--homeOffset);
}

/* framed board */
.hf-board{
  position:relative; width:104%; aspect-ratio:9/11.2;
  border-radius:15px; overflow:hidden; padding:14px;
  background: #010722;
  box-shadow:
    0 0 28px rgba(0,255,255,.25),
    0 10px 28px rgba(0,0,0,.45),
    inset 0 0 0 1px rgba(255,255,255,.12),
    inset 0 6px 16px rgba(0,0,0,.35);
  
}
/* inner vignette */
/*.hf-board::before{
  content:""; position:absolute; inset:0; pointer-events:none;
  background:
    radial-gradient(80% 100% at 50% 20%, rgba(0,0,0,.0), rgba(0,0,0,.28) 70%),
    linear-gradient(180deg, rgba(0,0,0,.25), rgba(0,0,0,0) 20%, rgba(0,0,0,0) 80%, rgba(0,0,0,.35));
}

/* sparkles */
.hf-sparkles{
  position:absolute; inset:0; pointer-events:none;
  background:
    radial-gradient(6px 6px at 20% 30%, rgba(124,87,255,.45), transparent 55%),
    radial-gradient(5px 5px at 78% 60%, rgba(124,87,255,.35), transparent 60%),
    radial-gradient(4px 4px at 12% 70%, rgb(255, 255, 255), transparent 60%);
  animation:infinite 6s linear infinite; filter: blur(1px); opacity:.55;
}
@keyframes hfDrift{ 0%{transform:translateY(0)} 50%{transform:translateY(-6px)} 100%{transform:translateY(0)} }

/* title */
.hf-title{
  position:absolute; left:52px; top:30px; z-index:2;
  margin:0; text-align:center; letter-spacing:1px; line-height:.9;
  color:#53FF11; font-weight:800;
  font-size:clamp(92px, 12vw, 92px);
  text-shadow:0 0 10px rgb(9, 255, 0), 0 0 40px rgba(101,255,87,.25);
  pointer-events:none;
  font-family: 'Microsoft Sans Serif';
}

/* compact 8Ã—12 grid */
.hf-grid{
  --hfCell: clamp(50px, 5.2vw, 30px);
  position:absolute; left:50%; top:60%; transform:translate(-50%,-50%);
  display:grid; gap:4px;
  grid-template-columns:repeat(8,var(--hfCell));
  grid-template-rows:repeat(8,var(--hfCell));
  

}
/* empty cell */
.hf-cell{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: #020723;         /* dimmer empties */
  box-shadow: inset 0 2px 0 #020723, inset 0 -3px 0 #020723;
  
}
/* center dark '+' cluster */
.hf-ghost{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: #0B102A;
  box-shadow:none;
  color: #0B102A;
}
/* more ghosts */
.hf-ghost2{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: #0B102A;
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost3{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(180deg, #090F27, #0C112D 100%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost4{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(180deg, #001126, #0C102D 100%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost5{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(90deg, #010C25, #080F28 100%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost6{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(90deg, #080F28, #010C25 100%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost7{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(180deg, #000C25, #000C25 100%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost8{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(225deg, #010722, #020B26 110%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost9{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(180deg, #0B152B 0%, #02303D 100%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost10{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: linear-gradient(270deg, #0B152B 0%, #02303D 100%);
  box-shadow:none;
  color: #0B102A;
}
.hf-ghost11{
  width:var(--hfCell); height:var(--hfCell); border-radius:13px;
  background: #0B152B;
  box-shadow:none;
  color: #0B102A;
}
/* colored blocks (gloss + glow) */
.hf-block{
  width:var(--hfCell); height:var(--hfCell); border-radius:10px;
  box-shadow: 0 0 18px rgba(255, 255, 255, 0.35),
              inset 0 2px 0 rgba(255, 255, 255, 0.60),
              inset 0 -3px 0 rgba(0, 0, 0, 0.35);
}
.hf-cyan   { background:linear-gradient(180deg,#7bf5ff,#00B5E5); }
.hf-magenta{ background:linear-gradient(180deg,#FF31F4,#9F0BDB); }
.hf-orange { background:linear-gradient(180deg,#FEA019,#CD7317); }

/* PLAY button */
.hf-cta{
  display:block; width:min(320px, 82%);
  font-weight:900; letter-spacing:3px;
  font-size:clamp(50px,3.6vw,28px);
  font-family: 'Microsoft Sans Serif';
  padding:16px 24px; border-radius:9999px; border:0; cursor:pointer;
  color:#000000;
  background:linear-gradient(180deg, var(--hf-cyan1), var(--hf-cyan2));
  box-shadow:
    0 0px 0px rgb(251, 252, 251),
    0 0 0 5px #00B3D0 inset,
    0 0 20px rgb(0, 225, 255);
}
.hf-cta{background: linear-gradient(180deg,#00F2E4,#0083C7);
  text-shadow:0 0 2px rgb(0, 0, 0);
  transition:transform .25s ease, filter 1.5s ease;}

.hf-cta:hover{ transform:translateY(+5px); filter:brightness(2); }
.hf-cta:active{ transform:translateY(+1px) scale(1); }

/* mini cards with small block grids */
.hf-tray{ display:flex; gap:14px; justify-content:center; align-items:center; }
#tray table{border-collapse:collapse}
#tray td{padding:0}
#tray .block{border-radius:10px}


.hf-card{
  width:150px; height:110px; border-radius:25px;
  background:#0B112B;
  display:grid; place-items:center;
}
.hf-mini{

 --m: clamp(30px, 2.8vw, 26px);
--g: calc(var(--m) / 13);                /* gap size (tweak this) */
 display:grid; 
 grid-template-columns: repeat(4, var(--m)); 
 gap: var(--g);                           /* adds space between squares */
}



/* Nudge the mini grid inside each card */
#homeOverlay .hf-tray .hf-card:nth-child(1) .hf-mini { position: relative; left: -2px; top: 12px; }
#homeOverlay .hf-tray .hf-card:nth-child(2) .hf-mini { position: relative; left:  15px; top: -15px; }
#homeOverlay .hf-tray .hf-card:nth-child(3) .hf-mini { position: relative; left:  15px; top: -2px; }

/* Base cells = invisible, keep grid positions */
.hf-mini .b{
  width:var(--m); height:var(--m);
  border-radius:0;            /* square corners like the game */
  background:transparent;     /* no fill for empty cells */
  box-shadow:none;            /* no faint edges on empty cells */
}

/* Only the COLOURED cells get the bevel/glow */
.hf-mini .b.mag{
  border-radius: 5px;  /* rounded corners for blocks */
  box-shadow: 0 0 5px rgb(255, 0, 0),
              inset 0 1px 0 rgba(255,255,255,.22),
              inset 0 -2px 0 rgba(0,0,0,.35);
}
.hf-mini .b.vio{
  border-radius: 5px;  /* rounded corners for blocks */
  box-shadow: 0 0 10px rgb(140, 0, 255),
              inset 0 1px 0 rgba(255,255,255,.22),
              inset 0 -2px 0 rgba(0,0,0,.35);
}
.hf-mini .b.orn{
  border-radius: 5px;  /* rounded corners for blocks */
  box-shadow: 0 0 5px rgb(51, 255, 0),
              inset 0 1px 0 rgba(255,255,255,.22),
              inset 0 -2px 0 rgba(0,0,0,.35);
}

.hf-mini .mag{ background:linear-gradient(180deg,#ff0000,#ff0000b4); }
.hf-mini .vio{ background:linear-gradient(180deg,#7A5CFF,#7c82ff); }
.hf-mini .orn{ background:linear-gradient(180deg,#9AFF00,#4bb630); }

:root{
  --base-w: 420;                 /* design width (px) */
  --base-h: 820;                 /* design height (px) */
  --ratio: calc(var(--base-w) / var(--base-h));
  --app-h: 100dvh;               /* mobile-safe viewport height */
  --max-game-w: 550px;           /* <- cap how wide the game can get */
}
@supports not (height: 100dvh) { :root { --app-h: 100vh; } }

html, body {
  height: 100%;
  margin: 0;
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
}
*, *::before, *::after { box-sizing: border-box; }
img, canvas, svg, video { max-width: 100%; height: auto; display: block; }
button, input, select, textarea { font: inherit; }

/* FULL-SCREEN background; center content */
.fitstage{
  min-height: var(--app-h);
  width: 100vw;
  display: grid;
  place-items: center;
  overflow: hidden;
  background: #0c121b;
  padding: env(safe-area-inset-top) env(safe-area-inset-right)
           env(safe-area-inset-bottom) env(safe-area-inset-left);
}

/* THE GAME AREA with locked aspect;
   - Sized by HEIGHT (not vw) so gutters don't squish it
   - Hard cap on width via --max-game-w
*/
.fitbox{
  aspect-ratio: var(--base-w) / var(--base-h);
  width: min(100%, calc(var(--app-h) * var(--ratio)));
  max-width: var(--max-game-w);
  max-height: var(--app-h);
  overflow: hidden;
}

.fitbox *{ min-width:0; min-height:0; }


</style>
</head>
<body>
<!-- Background demo -->
<div id="demoStage" class="stage">
  <div id="demoWrap" class="board-wrap">
    <div id="demoBoard" class="board"></div>
    <div id="demoPreview" class="preview-layer"></div>
    <div id="demoScore" class="score-banner">0</div>
    <div id="demoTray" class="tray"></div>
  </div>
</div>

<!-- Home + Menus -->
<div id="home" class="app center">
  <h1>Block Forge</h1>
  <div class="sub">Neon block-blast puzzle â€¢ Classic â€¢ Adventure â€¢ Tetris</div>
  <button onclick="showOffline()">Offline</button>
  <button onclick="showOnline()">Online</button>
  <button onclick="toggleTheme()">Theme</button>
</div>

<div id="offline" class="app center hidden">
  <h1>Offline Modes</h1>
  <div class="sub">Choose a mode</div>
  <button onclick="startMode('classic')">â–¶ Classic</button>
  <button onclick="startMode('adventure')">â–¶ Adventure</button>
  <button onclick="startMode('tetris')">â–¶ Tetris</button>
  <div style="margin-top:10px">
    <button onclick="showHome()">â¬… Home</button>
    <button onclick="toggleTheme()">â˜€/ðŸŒ™ Theme</button>
  </div>
</div>

<div id="online" class="app center hidden">
  <h1>Online Modes</h1>
  <button onclick="showHome()">â¬… Home</button>
</div>

<!-- Overlays -->
<div id="overlay" class="hidden">
  <h2>Game Over</h2>
  <button onclick="retryGame()">Retry</button>
  <button onclick="goHome()">Home</button>
</div>

<div id="backMenu" class="hidden">
  <h2>Pause</h2>
  <button onclick="(hideBackMenu(),goHome())">Home</button>
  <button id="ghostToggle" onclick="toggleGhostMode()">Ghost: Outline</button>
  <button onclick="(hideBackMenu(),retryGame())">Restart</button>
  <button onclick="hideBackMenu()">Cancel</button>
</div>

<!-- Game -->
<div id="game" class="app center hidden">
  <div id="score">0</div>
  <div id="hudLayer">
    <div id="comboBanner">Combo x1.00</div>
  </div>
  <div id="boardWrap" class="board-wrap">
    <div id="board" class="board"></div>
    
    <div id="preview" class="preview-layer"></div>
  </div>
  <div id="tray"></div>
  <div id="tetrisControls">
    <button onclick="tKey('Left')">â—€</button>
    <button onclick="tKey('Rotate')">âŸ²</button>
    <button onclick="tKey('Right')">â–¶</button>
    <button onclick="tKey('Down')">â–¼</button>
    <button onclick="tKey('Drop')">â¤“</button>
  </div>
  <button onclick="showBackMenu()">â¬… Back</button>
</div>

<script>
/* ---------- Shorthands ---------- */
const $=id=>document.getElementById(id);
const randi=n=>Math.floor(Math.random()*n);
const cellSize=()=>{ const b=$('board'); const v=b?parseInt(getComputedStyle(b).getPropertyValue('--cell'),10):NaN; return Number.isFinite(v)&&v>0?v:parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'),10); };
const pad=()=>parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pad'));
const gap=()=>parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'));


// Ctrl+Alt+R -> clear SW caches and hard-reload (dev only)
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.altKey && (e.key === 'r' || e.key === 'R')) {
    navigator.serviceWorker?.controller?.postMessage({ type: 'CLEAR_CACHES' });
    setTimeout(() => location.reload(true), 80);
  }
});



/* Disable SW + caches on localhost so changes show instantly */
if (/(^localhost$|^127\.0\.0\.1$)/.test(location.hostname)) {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations()
      .then(rs => rs.forEach(r => r.unregister()));
  }
  if ('caches' in window) {
    caches.keys().then(keys => keys.forEach(k => caches.delete(k)));
  }
}

/* iOS viewport nudge */
(function(){
  const setVh=()=>document.documentElement.style.setProperty('--vh', window.innerHeight*0.01+'px');
  window.addEventListener('resize', setVh, {passive:true});
  setVh();
})();

// Hard clear for Classic: zeros grid + cleans DOM + re-renders
function classicHardClear(lines) {
  const rows = lines?.rows || [];
  const cols = lines?.cols || [];
  const n = grid.length;

  // A) zero out DATA on the same grid Classic uses
  for (const r of rows) for (let c = 0; c < n; c++) grid[r][c] = 0;
  for (const c of cols) for (let r = 0; r < n; r++) grid[r][c] = 0;

  // B) clean up the DOM (classes/attrs) so visuals match data immediately
  const boardEl =
    document.querySelector('#board') ||           // try id=board
    document.querySelector('.classic-grid') ||    // try class=classic-grid
    document;                                     // fallback (still works)
  
  // clear row cells
  for (const r of rows) {
    for (let c = 0; c < n; c++) {
      const el = boardEl.querySelector(`[data-r="${r}"][data-c="${c}"]`);
      if (el) {
        el.classList.remove('clearing', 'row', 'col', 'filled', 'placed', 'block');
        el.removeAttribute('data-filled');
        el.style.removeProperty('--cDelay');
      }
    }
  }
  // clear col cells
  for (const c of cols) {
    for (let r = 0; r < n; r++) {
      const el = boardEl.querySelector(`[data-r="${r}"][data-c="${c}"]`);
      if (el) {
        el.classList.remove('clearing', 'row', 'col', 'filled', 'placed', 'block');
        el.removeAttribute('data-filled');
        el.style.removeProperty('--cDelay');
      }
    }
  }

  // C) re-render from data (forces UI â†” data sync)
  try { renderBoard(); } catch {}
}


function clearTetrisOverrides(){
  $('boardWrap')?.classList.remove('tetris');
  $('game')?.classList.remove('tetris');
  $('board')?.style.removeProperty('--cell');
  document.documentElement.style.removeProperty('--cell');
}

/* Fit Tetris board only */
function fitTetrisToViewport(){
  if (currentMode !== 'tetris') return;
  const boardEl = $('board'); if (!boardEl) return;
  const cols = width, rows = height, padPx = pad(), gapPx = gap();
  const trayH = $('tray') ? $('tray').offsetHeight : 0;
  const ctrlsEl = $('tetrisControls');
  const ctrlsH  = (ctrlsEl && ctrlsEl.style.display !== 'none') ? ctrlsEl.offsetHeight : 0;
  const headerH = 56;
  const vh = window.innerHeight, vw = window.innerWidth;
  const availH = Math.max(220, vh - trayH - ctrlsH - headerH - 16);
  const availW = Math.max(260, vw - 32);
  const cellFromH = Math.floor((availH - 2*padPx - (rows-1)*gapPx) / rows);
  const cellFromW = Math.floor((availW - 2*padPx - (cols-1)*gapPx) / cols);
  const size = Math.max(12, Math.min(cellFromH, cellFromW, 40));
  boardEl.style.setProperty('--cell', String(size));
  document.documentElement.style.removeProperty('--cell');
  sizePreviewLayer();
  renderBoard();
}

/* Score animation */
function animNumberOn(id, to, ms=600){
  const el = $(id); if(!el) return;
  const from = parseInt(el.textContent||'0',10) || 0;
  if(from === to){ el.textContent = String(to); return; }
  const t0 = performance.now();
  const ease = t=> t<.5 ? (4*t*t*t) : (1 - Math.pow(-2*t+2,3)/2);
  function tick(ts){
    const u = Math.min(1,(ts - t0)/ms);
    el.textContent = String(Math.round(from + (to - from) * ease(u)));
    if(u < 1) requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
}

/* ---------- UI feedback helpers ---------- */
function pulseScore(){ const el=$('score'); if(!el) return; el.classList.remove('score-pulse'); void el.offsetWidth; el.classList.add('score-pulse'); }
function showToast(text){ const hud=$('hudLayer'); if(!hud) return; const t=document.createElement('div'); t.className='toast'; t.textContent=text; hud.appendChild(t); setTimeout(()=>t.remove(), 750); }
function showComboBanner(mult){ const b=$('comboBanner'); if(!b) return; b.textContent=`Combo x${mult.toFixed(2)}`; if(!b.classList.contains('show')) b.classList.add('show'); b.classList.remove('bump'); void b.offsetWidth; b.classList.add('bump'); }
function floatPoints(text){ const hud=$('hudLayer'); if(!hud) return; const el=document.createElement('div'); el.className='float-score'; el.textContent=text; hud.appendChild(el); setTimeout(()=>el.remove(), 900); }
function hideComboBanner(){ const b=$('comboBanner'); if(b) b.classList.remove('show'); }
function uiPiecePlaced(cells){ if(cells>0){ floatPoints('+'+cells); pulseScore(); } }
function uiLinesCleared(lines, bonus){ if(lines<=0) return; const label=(lines===1?'Line':'Lines'); floatPoints(`${lines} ${label}! +${bonus}`); pulseScore(); }

/* ---------- Game data ---------- */
const COLORS=['#00e5ff','#ff3bff','#39ff14','#ffd166','#b784f5','#ff9f1c'];
const SHAPES=[[[1]],[[1,1]],[[1],[1]],[[1,1,1]],[[1],[1],[1]],[[1,1],[1,1]],[[1,1,1],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]]];
const copyShape=s=>s.map(r=>r.slice());
const randColor=()=>COLORS[randi(COLORS.length)];

let width=8,height=8,grid=[],score=0,tray=[],dragging=null,hoverCell=null,currentMode=null;
/* Ghost: 0 Off, 1 Outline, 2 Solid */
let ghostMode = 1;
/* Scoring / combo */
let comboLevel = 0, rackPieceUses = 0, rackCleared = false;
const CLEAR_MULTI = [0, 1.00, 1.80, 2.60, 3.20];
const COMBO_GROWTH = 1.25;

function cellsInShape(shape){ let n=0; for(let r=0;r<shape.length;r++)for(let c=0;c<shape[0].length;c++) if(shape[r][c]) n++; return n; }
function cellsClearedFrom(lines){ const rows=lines.rows.length, cols=lines.cols.length; if(!rows && !cols) return 0; return rows*width + cols*height - (rows*cols); }
function scoreForClear(lines){
  const linesCleared = (lines.rows?.length||0) + (lines.cols?.length||0);
  if(!linesCleared) return 0;
  const cellsCleared = cellsClearedFrom(lines);
  const multiIndex = Math.min(linesCleared, CLEAR_MULTI.length-1);
  const simultaneousMulti = CLEAR_MULTI[multiIndex];
  const comboBoost = Math.pow(COMBO_GROWTH, comboLevel);
  const perCell = 5;
  return Math.round(cellsCleared * perCell * simultaneousMulti * comboBoost);
}
function afterPlacementUpdateRack(didClear){
  if (currentMode === 'tetris') return;
  rackPieceUses++; if(didClear) rackCleared=true;
  if (rackPieceUses >= 3){
    const old = comboLevel;
    comboLevel = rackCleared ? (comboLevel+1) : 0;
    if (comboLevel>0){
      showComboBanner(Math.pow(COMBO_GROWTH, comboLevel));
      const b=$('comboBanner'); if(b){ b.classList.remove('levelUp'); void b.offsetWidth; b.classList.add('levelUp'); }
    } else if (old>0){ hideComboBanner(); }
    rackPieceUses=0; rackCleared=false;
  }
}

let gameOverQueued=false, isPaused=false;
function pauseGame(){ if(isPaused) return; isPaused=true; if(currentMode==='tetris' && tDropTimer){ clearInterval(tDropTimer); tDropTimer=null; } }
function resumeGame(){ if(!isPaused) return; isPaused=false; if(currentMode==='tetris' && !tDropTimer) tScheduleDrop(); }
function updateGhostBtn(){ const txt=['Off','Outline','Solid'][ghostMode]||'Outline'; const btn=$('ghostToggle'); if(btn) btn.textContent='Ghost: '+txt; }
function toggleGhostMode(){ ghostMode=(ghostMode+1)%3; updateGhostBtn(); tRenderGhost(); }

/* ---------- Tetris ---------- */
const TCOLORS={I:'#00e5ff',O:'#ffd166',T:'#b784f5',S:'#39ff14',Z:'#ff3bff',J:'#1ea7ff',L:'#ff9f1c'};
const TETROMINOES={I:[[1,1,1,1]],O:[[1,1],[1,1]],T:[[1,1,1],[0,1,0]],S:[[0,1,1],[1,1,0]],Z:[[1,1,0],[0,1,1]],J:[[1,0,0],[1,1,1]],L:[[0,0,1],[1,1,1]]};
let tActive=null,tX=0,tY=0,tRot=0,tDropTimer=null,tDropMs=900,tNext=null,tLines=0,tBag=[];
function tMatrixRotate(m){const h=m.length,w=m[0].length,r=Array.from({length:w},()=>Array(h).fill(0));for(let y=0;y<h;y++)for(let x=0;x<w;x++)r[x][h-1-y]=m[y][x];return r}
function tGetShape(name,rot){let m=TETROMINOES[name];for(let i=0;i<(rot%4+4)%4;i++)m=tMatrixRotate(m);return m}
function tShuffle(a){for(let i=a.length-1;i>0;i--){const j=randi(i+1);[a[i],a[j]]=[a[j],a[i]]}return a}
function tRefillBag(){ tBag=tShuffle(['I','O','T','S','Z','J','L']) }
function tDrawFromBag(){ if(!tBag.length) tRefillBag(); return tBag.shift() }
/* SRS kicks */
const SRS_JLSTZ={'0>1':[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],'1>0':[[0,0],[1,0],[1,-1],[0,2],[1,2]],'1>2':[[0,0],[1,0],[1,-1],[0,2],[1,2]],'2>1':[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],'2>3':[[0,0],[1,0],[1,1],[0,-2],[1,-2]],'3>2':[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],'3>0':[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],'0>3':[[0,0],[1,0],[1,1],[0,-2],[1,-2]]}
const SRS_I={'0>1':[[0,0],[-2,0],[1,0],[-2,-1],[1,2]],'1>0':[[0,0],[2,0],[-1,0],[2,1],[-1,-2]],'1>2':[[0,0],[-1,0],[2,0],[-1,2],[2,-1]],'2>1':[[0,0],[1,0],[-2,0],[1,-2],[-2,1]],'2>3':[[0,0],[2,0],[-1,0],[2,1],[-1,-2]],'3>2':[[0,0],[-2,0],[1,0],[-2,-1],[1,2]],'3>0':[[0,0],[1,0],[-2,0],[1,-2],[-2,1]],'0>3':[[0,0],[-1,0],[2,0],[-1,2],[2,-1]]}
function srsKicks(name,from,to){const k=`${from}>${to}`;if(name==='I')return SRS_I[k]||[[0,0]];if(name==='O')return [[0,0]];return SRS_JLSTZ[k]||[[0,0]]}

function tNewPiece(){
  if(tNext==null) tNext=tDrawFromBag();
  tActive=tNext; tRot=0;
  tX=Math.floor((width - tGetShape(tActive,0)[0].length)/2); tY=0;
  tNext=tDrawFromBag();
  if(tCollide(tX,tY,tActive,tRot)){ gameOverWithWave(); tStop(); return;}
  renderBoard(); tRenderNext();
}
function tCollide(nx,ny,name,rot){
  const s=tGetShape(name,rot);
  for(let y=0;y<s.length;y++)for(let x=0;x<s[0].length;x++){
    if(!s[y][x]) continue;
    const gx=nx+x, gy=ny+y;
    if(gx<0||gx>=width||gy>=height) return true;
    if(gy>=0 && grid[gy][gx]) return true;
  }
  return false;
}
function tMerge(){const s=tGetShape(tActive,tRot);for(let y=0;y<s.length;y++)for(let x=0;x<s[0].length;x++)if(s[y][x]){const gy=tY+y,gx=tX+x;if(gy>=0)grid[gy][gx]=TCOLORS[tActive]}};
function tClearLines(){
  let cleared=0;
  for(let y=height-1;y>=0;){
    if(grid[y].every(v=>!!v)){grid.splice(y,1);grid.unshift(Array(width).fill(0));cleared++} else y--;
  }
  if(cleared){
    tLines+=cleared;
    const gain=[0,100,300,500,800][cleared]||cleared*200;
    score+=gain; updateScore();
    if(tLines>=10){tLines-=10; tDropMs=Math.max(120,tDropMs-80); tScheduleDrop()}
    renderBoard();
  }
}
function tTick(){ if(!tActive) return; if(!tCollide(tX,tY+1,tActive,tRot)){ tY++; } else { tMerge(); tClearLines(); tNewPiece(); } renderBoard() }
function tScheduleDrop(){ if(tDropTimer) clearInterval(tDropTimer); tDropTimer=setInterval(tTick,tDropMs) }
function tStart(){ $('tetrisControls').style.display='flex'; tDropMs=900; tLines=0; tBag=[]; tRefillBag(); tNext=tDrawFromBag(); tNewPiece(); tScheduleDrop(); document.addEventListener('keydown',tKeydown) }
function tStop(){ $('tetrisControls').style.display='none'; if(tDropTimer){clearInterval(tDropTimer); tDropTimer=null} document.removeEventListener('keydown',tKeydown); $('preview').innerHTML=''}

function tKeydown(e){
  const k=e.key;
  if(['ArrowLeft','ArrowRight','ArrowDown','ArrowUp',' ','z','Z','x','X'].includes(k)) e.preventDefault();
  if(k==='ArrowLeft') tMove(-1);
  if(k==='ArrowRight') tMove(1);
  if(k==='ArrowDown') tSoft();
  if(k===' '||k==='ArrowUp') tHard();
  if(k==='z'||k==='Z') tRotate(-1);
  if (isPaused) return;
  if(k==='x'||k==='X') tRotate(1);
  renderBoard();
}
function tKey(btn){ if(btn==='Left') tMove(-1); if(btn==='Right') tMove(1); if(btn==='Down') tSoft(); if(btn==='Drop') tHard(); if (isPaused) return; if(btn==='Rotate') tRotate(1); renderBoard() }
function tMove(dx){ if(!tCollide(tX+dx,tY,tActive,tRot)) { tX+=dx; tRenderGhost(); } }
function tSoft(){ if(!tCollide(tX,tY+1,tActive,tRot)){ tY++; score+=1; updateScore(); tRenderGhost(); } }
function tHard(){ let dy=0; while(!tCollide(tX,tY+dy+1,tActive,tRot)) dy++; tY+=dy; score+=2*dy; updateScore(); tTick() }
function tRotate(dir){
  const from=tRot,to=(tRot+dir+4)%4,kicks=srsKicks(tActive,from,to);
  for(const [dx,dy] of kicks){
    const nx=tX+dx, ny=tY+dy;
    if(!tCollide(nx,ny,tActive,to)){ tX=nx; tY=ny; tRot=to; tRenderGhost(); return; }
  }
}
function tRenderNext(){
  const el=$('tray'); el.innerHTML=''; if(!tNext) return;
  const s=tGetShape(tNext,0);
  const table=document.createElement('table'); table.cellSpacing=0;
  for(let r=0;r<s.length;r++){
    const tr=document.createElement('tr');
    for(let c=0;c<s[0].length;c++){
      const td=document.createElement('td');
      td.style.width=td.style.height=Math.floor(cellSize()*0.5)+'px';
      if(s[r][c]){ td.className='block'; td.style.backgroundColor=TCOLORS[tNext]; }
      tr.appendChild(td);
    }
    tr.style.lineHeight=0; table.appendChild(tr);
  }
  const wrap=document.createElement('div'); wrap.className='piece slot'; wrap.appendChild(table); el.appendChild(wrap);
  fitTetrisToViewport();
}

/* Ghost */
function tRenderGhost(){
  const layer=$('preview');
  if (currentMode!=='tetris' || !tActive || ghostMode===0){ if(layer) layer.innerHTML=''; return; }
  let gy=tY; while(!tCollide(tX,gy+1,tActive,tRot)) gy++;
  if (gy===tY){ layer.innerHTML=''; return; }
  layer.classList.remove('valid','invalid'); layer.innerHTML='';
  const s=cellSize(), p=pad(), g=gap();
  const shape=tGetShape(tActive,tRot), color=TCOLORS[tActive];
  for(let r=0;r<shape.length;r++)for(let c=0;c<shape[0].length;c++){
    if(!shape[r][c]) continue;
    const pb=document.createElement('div');
    pb.className='preview-block';
    pb.style.width  = s + 'px';
    pb.style.height = s + 'px';
    pb.style.left=(p+(tX+c)*(s+g))+'px';
    pb.style.top =(p+(gy+r)*(s+g))+'px';
    if(ghostMode===1){
      pb.style.backgroundColor='transparent';
      pb.style.opacity='1';
      pb.style.boxShadow='none';
      pb.style.border='2px solid '+color;
    }else{
      pb.style.backgroundColor=color;
      pb.style.opacity='.35';
    }
    layer.appendChild(pb);
  }
}

/* Core helpers */
function setBoardDimensions(cols,rows){ width=cols;height=rows; $('board').style.setProperty('--cols', String(cols)); }
function hideAll(){['home','offline','online','game'].forEach(x=>$(x).classList.add('hidden'))}

function showHome(){ tStop(); startDemo(); hideAll(); $('home').classList.remove('hidden'); clearTetrisOverrides(); }
function showOffline(){ tStop(); startDemo(); hideAll(); $('offline').classList.remove('hidden'); clearTetrisOverrides(); }
function showOnline(){ tStop(); startDemo(); hideAll(); $('online').classList.remove('hidden'); clearTetrisOverrides(); }

function toggleTheme(){ document.body.classList.toggle('light') }

/* Start modes */
function startMode(mode){
  currentMode = mode;
  tStop(); stopDemo();
  hideAll(); $('game').classList.remove('hidden');

  if (mode==='classic' || mode==='adventure'){
    clearTetrisOverrides();
    setBoardDimensions(8,8);
    resetGame();
    $('preview').innerHTML='';
    return;
  }
  if (mode==='tetris'){
    clearTetrisOverrides();
    setBoardDimensions(10,20);
    resetGame(); tStart(); sizePreviewLayer();
    $('boardWrap').classList.add('tetris');
    $('game').classList.add('tetris');
    fitTetrisToViewport();
    return;
  }
}

function retryGame(){ hideGameOverOverlay(); startMode(currentMode) }
function goHome(){ hideGameOverOverlay(); showHome() }
function showBackMenu(){ pauseGame(); $('backMenu').classList.remove('hidden'); updateGhostBtn(); }
function hideBackMenu(){ $('backMenu').classList.add('hidden'); resumeGame(); }
function showGameOverOverlay(){ $('overlay').classList.remove('hidden') }
function hideGameOverOverlay(){ $('overlay').classList.add('hidden') }

/* Render & gameplay */
function resetGame(){ grid=Array.from({length:height},()=>Array(width).fill(0)); score=0; updateScore(false); refillTray(); renderBoard(); renderTray(); sizePreviewLayer(); requestAnimationFrame(()=>boardWave('in')) }
function updateScore(animate=true){ if(animate) animNumberOn('score', score, 400); else $('score').textContent=String(score) }
function renderBoard(){
  const b=$('board'); b.innerHTML='';
  for(let y=0;y<height;y++)for(let x=0;x<width;x++){
    const d=document.createElement('div');const v=grid[y][x];
    d.className='cell '+(v?'block':''); if(v) d.style.backgroundColor=v;
    b.appendChild(d);
  }
  if(currentMode==='tetris'){
    tRenderGhost();
    if(tActive){
      const s=tGetShape(tActive,tRot);
      for(let r=0;r<s.length;r++)for(let c=0;c<s[0].length;c++){
        if(!s[r][c]) continue; const gy=tY+r,gx=tX+c;
        if(gy>=0 && gy<height && gx>=0 && gx<width){
          const idx=gy*width+gx, cell=b.children[idx];
          if(cell){ cell.classList.add('block'); cell.style.backgroundColor=TCOLORS[tActive]; cell.style.outline='2px dashed rgba(255,255,255,.22)'; cell.style.outlineOffset='-3px'; }
        }
      }
    }
  }
}

function makePiece(){return{shape:copyShape(SHAPES[randi(SHAPES.length)]),color:randColor(),used:false}}
function refillTray(){ if(currentMode==='tetris'){ tRenderNext(); return; } if(tray.length===0||tray.every(p=>p.used)) tray=[makePiece(),makePiece(),makePiece()] }
function renderTray(){
  if(currentMode==='tetris'){ tRenderNext(); return; }
  const el=$('tray'); el.innerHTML='';
  for(let i=0;i<3;i++){
    const p=tray[i]; const card=document.createElement('div'); card.className='piece slot';
    const sizeHalf=Math.floor(cellSize()*0.5);
    if(p&&!p.used){
      const t=document.createElement('table'); t.cellSpacing=0;
      p.shape.forEach(row=>{
        const tr=document.createElement('tr');
        row.forEach(v=>{
          const td=document.createElement('td');
          td.style.width=td.style.height=sizeHalf+'px';
          if(v){ td.className='block'; td.style.backgroundColor=p.color }
          tr.appendChild(td);
        });
        tr.style.lineHeight=0; t.appendChild(tr);
      });
      card.appendChild(t);
      card.addEventListener('pointerdown',e=>{e.preventDefault();startDrag(p,e.clientX,e.clientY)},{passive:false});
      card.addEventListener('touchstart',e=>{if(!e.touches||!e.touches[0])return;e.preventDefault();const t=e.touches[0];startDrag(p,t.clientX,t.clientY)},{passive:false});
    }else{
      card.classList.add('placeholder'); card.style.minWidth='120px'; card.style.minHeight='120px';
      const ghost=document.createElement('div'); ghost.style.width=ghost.style.height=sizeHalf+'px'; ghost.style.opacity='0'; card.appendChild(ghost);
    }
    el.appendChild(card);
  }
}

function sizePreviewLayer(){
  const board = $('board');
  const layer = $('preview');
  const wrap  = $('boardWrap');
  if(!board || !layer || !wrap) return;
  layer.style.width  = board.clientWidth + 'px';
  layer.style.height = board.clientHeight + 'px';
  layer.style.left = board.offsetLeft + 'px';
  layer.style.top  = board.offsetTop  + 'px';
}

/* Drag logic (non-Tetris) */
function clearPreview(){const layer=$('preview');layer.classList.remove('valid','invalid');layer.innerHTML=''}
function drawPreview(piece,ax,ay){
  if(currentMode==='tetris') return;
  const layer=$('preview'); clearPreview(); if(ax==null||ay==null) return;
  const valid=canPlace(piece.shape,ax,ay); layer.classList.add(valid?'valid':'invalid');
  const s=cellSize(),p=pad(),g=gap();
  for(let r=0;r<piece.shape.length;r++)for(let c=0;c<piece.shape[0].length;c++){
    if(!piece.shape[r][c])continue;
    const pb=document.createElement('div'); pb.className='preview-block';
    pb.style.left=(p+(ax+c)*(s+g))+'px'; pb.style.top=(p+(ay+r)*(s+g))+'px';
    pb.style.backgroundColor=piece.color; layer.appendChild(pb);
  }
}
function canPlace(shape,x,y){
  for(let r=0;r<shape.length;r++)for(let c=0;c<shape[0].length;c++){
    if(!shape[r][c])continue; const yy=y+r,xx=x+c;
    if(xx<0||yy<0||xx>=width||yy>=height) return false;
    if(grid[yy][xx]) return false;
  } return true;
}
function applyPiece(piece,x,y){
  const placed=[]; for(let r=0;r<piece.shape.length;r++)for(let c=0;c<piece.shape[0].length;c++){
    if(!piece.shape[r][c])continue; grid[y+r][x+c]=piece.color; placed.push({x:x+c,y:y+r});
  } return placed;
}
function detectFullLines(){
  const rows=[],cols=[];
  for(let y=0;y<height;y++){ if(grid[y].every(v=>!!v)) rows.push(y) }
  for(let x=0;x<width;x++){ let full=true; for(let y=0;y<height;y++){ if(!grid[y][x]){full=false;break} } if(full) cols.push(x) }
  return {rows,cols}
}
function animatePlacedCells(cells){ if(currentMode==='tetris') return; const b=$('board'); cells.forEach(({x,y})=>{const idx=y*width+x; const cell=b.children[idx]; if(cell){ cell.style.animation='pop .26s ease'; setTimeout(()=>{cell.style.animation=''},280) }}) }



function getAudioCtx() {
  if (__audioCtx) return __audioCtx;
  const AC = window.AudioContext || window.webkitAudioContext;
  if (!AC) return null; // no WebAudio support
  __audioCtx = new AC();
  return __audioCtx;
}

// Unlock audio on first user gesture (mobile needs this)
function __unlockAudio() {
  const ctx = getAudioCtx();
  if (!ctx) return;
  if (ctx.state === 'suspended') ctx.resume();
  // Tiny silent tick to satisfy some browsers
  try {
    const b = ctx.createBuffer(1, 1, 22050);
    const s = ctx.createBufferSource();
    s.buffer = b; s.connect(ctx.destination); s.start(0);
  } catch {}
  audioOK = true;
  document.removeEventListener('pointerdown', __unlockAudio);
  document.removeEventListener('touchstart', __unlockAudio);
  document.removeEventListener('click', __unlockAudio);
}
document.addEventListener('pointerdown', __unlockAudio, { once: true });
document.addEventListener('touchstart', __unlockAudio, { once: true });
document.addEventListener('click', __unlockAudio, { once: true });

function playClearSound(){
  const ctx = getAudioCtx();
if (!ctx) return; // skip until audio context exists

 // skip until user taps/clicks

  const o = ctx.createOscillator();
  const g = ctx.createGain();

  o.type = 'triangle';
  const t = ctx.currentTime;

  o.frequency.setValueAtTime(660, t);
  o.frequency.exponentialRampToValueAtTime(990, t + 0.08);

  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.25, t + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);

  o.connect(g).connect(ctx.destination);
  o.start(t);
  o.stop(t + 0.2);
}

function animateAndClear(lines){
  if (currentMode === 'tetris') return Promise.resolve(0);
  const { rows, cols } = lines;
  if (!rows.length && !cols.length) return Promise.resolve(0);

  const b = $('board'); // classic board element
  for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) {
    const isRow = rows.includes(y), isCol = cols.includes(x);
    if (isRow || isCol) {
      const idx = y * width + x;
      const cell = b.children[idx];
      if (cell && grid[y][x]) {
        cell.style.animation = 'jumpOut .2s ease both';
        cell.style.setProperty('--cDelay', '140ms');
        cell.classList.add('clearing', isRow ? 'row' : 'col');
      }
    }
  }

  try { playClearSound(); } catch (_) {}

  // read CSS var and fall back if missing
  const cssMs = parseInt(getComputedStyle(document.documentElement)
                   .getPropertyValue('--clear-ms')) || 420;
  const delay = cssMs + 160;

  return new Promise(res => setTimeout(() => {
    // 1) ZERO DATA IN-PLACE (donâ€™t replace row arrays)
    for (const y of rows) for (let x = 0; x < width; x++) grid[y][x] = 0;
    for (const x of cols) for (let y = 0; y < height; y++) grid[y][x] = 0;

    // 2) RE-RENDER FROM DATA
    renderBoard();

    // 3) BELT & BRACES: strip any lingering classes/attrs from cleared cells
    //    (prevents visuals staying filled if renderBoard missed anything)
    const boardEl = $('board') || document;
    for (const y of rows) for (let x = 0; x < width; x++) {
      const idx = y * width + x;
      const el = boardEl.children[idx];
      if (el) {
        el.classList.remove('clearing','row','col','filled','placed','block');
        el.removeAttribute?.('data-filled');
        el.style.removeProperty?.('--cDelay');
      }
    }
    for (const x of cols) for (let y = 0; y < height; y++) {
      const idx = y * width + x;
      const el = boardEl.children[idx];
      if (el) {
        el.classList.remove('clearing','row','col','filled','placed','block');
        el.removeAttribute?.('data-filled');
        el.style.removeProperty?.('--cDelay');
      }
    }

    res(rows.length + cols.length);
  }, delay));
}


function startDrag(piece,cx,cy){
  if(currentMode==='tetris') return;
  dragging={piece};
  document.addEventListener('pointermove',onDragMove,{passive:false});
  document.addEventListener('touchmove',onTouchMove,{passive:false});
  const end=e=>{onDragEnd(e);cleanup()};
  const cancel=()=>{dragging=null;clearPreview();cleanup()};
  function cleanup(){
    document.removeEventListener('pointermove',onDragMove);
    document.removeEventListener('touchmove',onTouchMove);
    document.removeEventListener('pointerup',end);
    document.removeEventListener('pointercancel',cancel);
    document.removeEventListener('touchend',end);
    document.removeEventListener('touchcancel',cancel);
  }
  document.addEventListener('pointerup',end,{once:true});
  document.addEventListener('pointercancel',cancel,{once:true});
  document.addEventListener('touchend',end,{once:true});
  document.addEventListener('touchcancel',cancel,{once:true});
  onDragMove({clientX:cx,clientY:cy,preventDefault(){}});
}
function onTouchMove(e){ if(!dragging)return; if(!e.touches||!e.touches[0])return; e.preventDefault(); const t=e.touches[0]; onDragMove({clientX:t.clientX,clientY:t.clientY,preventDefault(){}}) }
function onDragMove(e){
  if(!dragging)return; if(e&&e.preventDefault) e.preventDefault();
  const rect=$('board').getBoundingClientRect(), s=cellSize(),p=pad(),g=gap();
  const inside=e.clientX>=rect.left+p&&e.clientX<rect.right-p&&e.clientY>=rect.top+p&&e.clientY<rect.bottom-p;
  if(!inside){hoverCell=null;clearPreview();return}
  const x=Math.floor((e.clientX-rect.left-p)/(s+g));
  const y=Math.floor((e.clientY-rect.top -p)/(s+g));
  hoverCell={x,y}; drawPreview(dragging.piece,x,y);
}
async function onDragEnd(e){
  if(!dragging){ clearPreview(); return; }
  const p = dragging.piece; dragging = null;
  if(!hoverCell){ clearPreview(); return; }
  const { x, y } = hoverCell;
  if (!canPlace(p.shape, x, y)) { clearPreview(); return; }

  /* 1) Place */
  const placed = applyPiece(p, x, y);
  p.used = true;

  /* 2) Base score */
  const placedCells = cellsInShape(p.shape);
  score += placedCells;
  uiPiecePlaced(placedCells);
  renderBoard();
  animatePlacedCells(placed);

  /* 3) Clear detection + bonus */
  const lines = detectFullLines();
  const clearedCount = (lines.rows.length + lines.cols.length);
  if (clearedCount > 0) {
    await animateAndClear(lines);
    renderBoard();
    const bonus = scoreForClear(lines);
    score += bonus;

    const linesCleared = clearedCount;
    const simMultiIndex = Math.min(linesCleared, CLEAR_MULTI.length-1);
    const simMulti = CLEAR_MULTI[simMultiIndex];
    const comboMulti = Math.pow(COMBO_GROWTH, comboLevel);
    let tag = `+${bonus}`;
    if (linesCleared > 1) tag += ` (x${simMulti.toFixed(2)})`;
    if (comboLevel > 0)   tag += ` (combo x${comboMulti.toFixed(2)})`;
    floatPoints(tag);
  }

  /* 4) Combo bookkeeping */
  afterPlacementUpdateRack(clearedCount > 0);

  /* 5) Refill / check moves */
  if (currentMode && (currentMode === 'classic' || currentMode === 'adventure')) {
    refillTray(); renderTray(); updateScore(); ensureMovesOrGameOver();
  } else {
    refillTray(); renderTray(); updateScore();
  }
  clearPreview();
}
function hasAnyValidMove(){
  const pieces = tray.filter(p => !p.used);
  if (pieces.length === 0) return true;
  for (const piece of pieces){
    for (let y=0; y<height; y++){
      for (let x=0; x<width; x++){
        if (canPlace(piece.shape, x, y)) return true;
      }
    }
  }
  return false;
}
function ensureMovesOrGameOver(){
  if(currentMode==='classic'||currentMode==='adventure'){
    const anyUnused=tray.some(p=>!p.used);
    if(anyUnused && !hasAnyValidMove()){ setTimeout(()=>gameOverWithWave(),200) }
  }
}

/* Waves / Game over */
function boardWave(type){
  const cells=[...$('board').children], base=type==='out'?520:420, step=38, jumpOffset=type==='in'?140:100;
  cells.forEach((cell,i)=>{const x=i%width,y=(i/width)|0,d=(x+y)*step;cell.style.animation='';
    if(type==='in'){cell.style.animation=`waveIn .42s ease both ${d}ms, jumpOut .2s ease both ${d+jumpOffset}ms`;}
    else{cell.style.animation=`waveOut .52s ease both ${d}ms, jumpOut .2s ease both ${d+jumpOffset}ms`;}
  });
  const total=(width+height)*step+base+jumpOffset+260;
  return new Promise(res=>setTimeout(()=>{cells.forEach(c=>c.style.animation='');res()},total))
}
async function gameOverWithWave(){ if(gameOverQueued) return; gameOverQueued=true; await boardWave('out'); showGameOverOverlay(); tStop(); gameOverQueued=false }

/* expose for inline onclick */
Object.assign(window,{showHome,showOffline,showOnline,startMode,retryGame,goHome,toggleTheme,showBackMenu,hideBackMenu,tKey})

/* ===== Background Demo ===== */
var dGrid=[],dScore=0,dPlacing=false,dTray=[];var demoRunning=false,dTick=null;const dW=8,dH=8
function dMakePiece(){return{shape:copyShape(SHAPES[randi(SHAPES.length)]),color:randColor(),used:false}}
function dRefillTray(){if(dTray.length===0||dTray.every(p=>p.used))dTray=[dMakePiece(),dMakePiece(),dMakePiece()]}
function dRenderTray(){const el=$('demoTray');el.innerHTML='';for(let i=0;i<3;i++){const p=dTray[i];const card=document.createElement('div');card.className='piece slot';const sizeHalf=Math.floor(cellSize()*0.5);if(p&&!p.used){const t=document.createElement('table');t.cellSpacing=0;p.shape.forEach(row=>{const tr=document.createElement('tr');row.forEach(v=>{const td=document.createElement('td');td.style.width=td.style.height=sizeHalf+'px';if(v){td.className='block';td.style.backgroundColor=p.color}tr.appendChild(td)});tr.style.lineHeight=0;t.appendChild(tr)});card.appendChild(t)}else{card.classList.add('placeholder');card.style.minWidth='120px';card.style.minHeight='120px';const ghost=document.createElement('div');ghost.style.width=ghost.style.height=sizeHalf+'px';ghost.style.opacity='0';card.appendChild(ghost)}el.appendChild(card)}}
function resetDemo(){dGrid=Array.from({length:dH},()=>Array(dW).fill(0));dScore=0;$('demoBoard').style.setProperty('--cols','8');$('demoScore').textContent='0';dTray=[];dRefillTray();dRenderTray();renderDemoBoard();sizeDemoPreviewFixed()}
function renderDemoBoard(){const b=$('demoBoard');b.innerHTML='';for(let y=0;y<dH;y++){for(let x=0;x<dW;x++){const d=document.createElement('div');const v=dGrid[y][x];d.className='cell '+(v?'block':'');if(v)d.style.backgroundColor=v;b.appendChild(d)}}}
function sizeDemoPreviewFixed(){const board=$('demoBoard');const layer=$('demoPreview');const r=board.getBoundingClientRect();layer.style.width=r.width+'px';layer.style.height=r.height+'px';layer.style.left=board.offsetLeft+'px';layer.style.top=board.offsetTop+'px'}
function dCanPlace(shape,x,y){for(let r=0;r<shape.length;r++){for(let c=0;c<shape[0].length;c++){if(!shape[r][c])continue;const yy=y+r,xx=x+c;if(xx<0||yy<0||xx>=dW||yy>=dH)return false;if(dGrid[yy][xx])return false}}return true}
function dCloneGrid(g){return g.map(row=>row.slice())}
function dDetect(g){const rows=[],cols=[];for(let y=0;y<dH;y++)if(g[y].every(v=>!!v))rows.push(y);for(let x=0;x<dW;x++){let full=true;for(let y=0;y<dH;y++){if(!g[y][x]){full=false;break}}if(full)cols.push(x)}return{rows,cols}}
function dClearOn(g,rows,cols){rows.forEach(y=>{g[y]=Array(dW).fill(0)});cols.forEach(x=>{for(let y=0;y<dH;y++)g[y][x]=0})}
function dAdjacencyScore(g,shape,x,y){let s=0;for(let r=0;r<shape.length;r++){for(let c=0;c<shape[0].length;c++){if(!shape[r][c])continue;const yy=y+r,xx=x+c;[[1,0],[-1,0],[0,1],[0,-1]].forEach(([dy,dx])=>{const ny=yy+dy,nx=xx+dx;if(ny>=0&&ny<dH&&nx>=0&&nx<dW&&g[ny][nx])s++})}}return s}
function dCenterDistance(shape,x,y){const cx=(dW-1)/2,cy=(dH-1)/2;let ax=0,ay=0,n=0;for(let r=0;r<shape.length;r++){for(let c=0;c<shape[0].length;c++){if(!shape[r][c])continue;ax+=x+c;ay+=y+r;n++}}if(!n)return 0;ax/=n;ay/=n;const dx=ax-cx,dy=ay-cy;return Math.hypot(dx,dy)}
function dMobility(g){const shapes=[SHAPES[0],SHAPES[3],SHAPES[5],SHAPES[6]];let count=0;for(const s of shapes){for(let y=0;y<dH;y++){for(let x=0;x<dW;x++){let ok=true;for(let r=0;r<s.length;r++){for(let c=0;c<s[0].length;c++){if(!s[r][c])continue;const yy=y+r,xx=x+c;if(xx<0||yy<0||xx>=dW||yy>=dH||g[yy][xx]){ok=false;break}}if(!ok)break}if(ok){count++;if(count>50)return count}}}}return count}
function dEvalPlacement(piece,x,y){if(!dCanPlace(piece.shape,x,y))return null;const g=dCloneGrid(dGrid);for(let r=0;r<piece.shape.length;r++){for(let c=0;c<piece.shape[0].length;c++){if(piece.shape[r][c])g[y+r][x+c]=1}}const det=dDetect(g);const clears=det.rows.length+det.cols.length;if(clears)dClearOn(g,det.rows,det.cols);const adj=dAdjacencyScore(g,piece.shape,x,y);const center=dCenterDistance(piece.shape,x,y);const mob=dMobility(g);const score=clears*1000+adj*3+mob*0.6-center*0.4;return{score,clears,adj,center,mob,x,y}}
function dChooseBest(){dRefillTray();let best=null,bestIdx=-1;for(let i=0;i<dTray.length;i++){const p=dTray[i];if(p.used)continue;for(let y=0;y<dH;y++){for(let x=0;x<dW;x++){const ev=dEvalPlacement(p,x,y);if(ev&&(!best||ev.score>best.score)){best=ev;bestIdx=i}}}}return best?{idx:bestIdx,move:best}:null}
function dDrawPreview(shape,color,x,y){const layer=$('demoPreview');layer.innerHTML='';const p=pad(),g=gap(),s=cellSize();layer.classList.remove('valid','invalid');layer.classList.add('valid');for(let r=0;r<shape.length;r++){for(let c=0;c<shape[0].length;c++){if(!shape[r][c])continue;const pb=document.createElement('div');pb.className='preview-block';pb.style.left=(p+(x+c)*(s+g))+'px';pb.style.top=(p+(y+r)*(s+g))+'px';pb.style.backgroundColor=color;pb.style.animation='demoDrag .6s ease';layer.appendChild(pb)}}}
function dAnimatePlacedCells(cells){const b=$('demoBoard');cells.forEach(({x,y})=>{const idx=y*dW+x;const cell=b.children[idx];if(cell){cell.style.animation='pop .26s ease';setTimeout(()=>{cell.style.animation=''},280)}})}
function dAnimateAndClear(lines){const{rows,cols}=lines;if(rows.length===0&&cols.length===0)return Promise.resolve(0);const b=$('demoBoard');for(let y=0;y<dH;y++){for(let x=0;x<dW;x++){const isRow=rows.includes(y),isCol=cols.includes(x);if(isRow||isCol){const idx=y*dW+x;const cell=b.children[idx];if(cell&&dGrid[y][x]){cell.classList.add('clearing',isRow?'row':'col')}}}}try{playClearSound()}catch(_){}const delay=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--clear-ms'))+160;return new Promise(res=>{setTimeout(()=>{rows.forEach(y=>{dGrid[y]=Array(dW).fill(0)});cols.forEach(x=>{for(let y=0;y<dH;y++)dGrid[y][x]=0});renderDemoBoard();res(rows.length+cols.length)},delay)})}
function dThinkingSequenceSmooth(piece,move){return new Promise(resolve=>{const layer=$('demoPreview');layer.innerHTML='';const s=cellSize(), p=pad(), g=gap();const startY = p + (dH + 2) * (s + g);const startX = p + Math.floor(dW/2) * (s + g);const targetLefts=[], targetTops=[], blocks=[];for(let r=0;r<piece.shape.length;r++){for(let c=0;c<piece.shape[0].length;c++){if(!piece.shape[r][c]) continue;const left = p + (move.x + c) * (s + g);const top  = p + (move.y + r) * (s + g);const pb=document.createElement('div');pb.className='preview-block';pb.style.backgroundColor=piece.color;pb.style.left=startX+'px';pb.style.top=startY+'px';layer.appendChild(pb);targetLefts.push(left); targetTops.push(top); blocks.push(pb);}}const ease = t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;const duration = 650 + Math.random()*180;let t0=null, hold=120+Math.random()*140;function tick(ts){if(!t0){ t0=ts; return requestAnimationFrame(tick);}const dt=ts-t0;if(dt<hold) return requestAnimationFrame(tick);const u=Math.min(1,(dt-hold)/duration);const e=ease(u);for(let i=0;i<blocks.length;i++){const bx= startX + (targetLefts[i]-startX)*e;const by= startY + (targetTops[i]-startY)*e;blocks[i].style.left = bx+'px';blocks[i].style.top  = by+'px';}if(u<1) requestAnimationFrame(tick); else setTimeout(resolve,120);}requestAnimationFrame(tick);})}
async function dStep(){if(dPlacing||!demoRunning)return;dPlacing=true;dRefillTray();dRenderTray();const pick=dChooseBest();if(!pick){resetDemo();dPlacing=false;return}const piece=dTray[pick.idx];const m=pick.move;await dThinkingSequenceSmooth(piece,m);for(let r=0;r<piece.shape.length;r++){for(let c=0;c<piece.shape[0].length;c++){if(piece.shape[r][c])dGrid[m.y+r][m.x+c]=piece.color}}renderDemoBoard();const placed=[];for(let r=0;r<piece.shape.length;r++){for(let c=0;c<piece.shape[0].length;c++){if(piece.shape[r][c])placed.push({x:m.x+c,y:m.y+r})}}dAnimatePlacedCells(placed);const det=dDetect(dGrid);const cleared=det.rows.length+det.cols.length;if(cleared){await dAnimateAndClear(det);dScore+=cleared*100;animNumberOn('demoScore', dScore, 500)}$('demoPreview').innerHTML='';piece.used=true;if(dTray.every(p=>p.used))dTray=[];dPlacing=false}
function dLoop(){if(!demoRunning)return;Promise.resolve(dStep()).finally(()=>{if(!demoRunning)return;dTick=setTimeout(dLoop,850)})}
function startDemo(){if(demoRunning)return;demoRunning=true;resetDemo();$('demoStage').classList.remove('hidden');dLoop()}
function stopDemo(){demoRunning=false;if(dTick){clearTimeout(dTick);dTick=null}$('demoStage').classList.add('hidden');$('demoPreview').innerHTML=''}

/* ---------------- Self Tests ---------------- */
function runSelfTests(){
  const results=[]; const pass=(name)=>results.push({test:name, pass:true}); const fail=(name,msg)=>results.push({test:name, pass:false, msg});
  try{ const fns=['showHome','showOffline','showOnline','startMode','retryGame','goHome','toggleTheme']; const ok=fns.every(k=>typeof window[k]==='function'); ok?pass('globals'):fail('globals','Missing:'+fns.filter(k=>typeof window[k]!=='function').join(',')); }catch(e){ fail('globals', e.message) }
  try{ let ok=true; for(const k of Object.keys(TETROMINOES)){ for(let r=0;r<4;r++){ const m=tGetShape(k,r); const cnt=m.flat().reduce((a,b)=>a+(b?1:0),0); if(cnt!==4) ok=false; } } ok?pass('tetromino counts'):fail('tetromino counts','not 4') }catch(e){ fail('tetromino counts', e.message)}
  try{ tRefillBag(); const set=new Set(tBag); (tBag.length===7 && set.size===7) ? pass('7-bag size & uniqueness') : fail('7-bag size & uniqueness', JSON.stringify(tBag)); }catch(e){ fail('7-bag', e.message) }
  try{ setBoardDimensions(10,20); grid=Array.from({length:height},()=>Array(width).fill(0)); tActive='J'; tRot=0; tX=0; tY=0; const before=tCollide(tX,tY,tActive,1); tRotate(1); const after=!tCollide(tX,tY,tActive,tRot); (before && after) ? pass('SRS wall kick J 0>1 at wall') : fail('SRS wall kick J 0>1 at wall', JSON.stringify({before,after,tX,tY,tRot})) }catch(e){ fail('SRS wall kick J', e.message)}
  try{ setBoardDimensions(10,20); grid=Array.from({length:height},()=>Array(width).fill(0)); tActive='I'; tRot=0; tX=width-4; tY=0; const before=tCollide(tX,tY,tActive,1); tRotate(1); const after=!tCollide(tX,tY,tActive,tRot); (before && after) ? pass('SRS wall kick I 0>1 at wall') : fail('SRS wall kick I 0>1 at wall', JSON.stringify({before,after,tX,tY,tRot})) }catch(e){ fail('SRS wall kick I', e.message)}
  console.log('%cBlock Forge self-tests', 'color:#39ff14;font-weight:700'); console.table(results);
}

/* Listeners */
window.addEventListener('resize', ()=>{ sizePreviewLayer(); sizeDemoPreviewFixed(); fitTetrisToViewport(); }, {passive:true});
// Build the framed grid + decorative blocks + mini cards to match the reference
function initHomeArt(){
  const grid = document.getElementById('hfGrid');
  if (!grid || grid.dataset.built) return;

  const COLS = 6, ROWS = 8;

  // 1) dark grid cells
  for (let i = 0; i < COLS*ROWS; i++){
    const s = document.createElement('i');
    s.className = 'hf-cell';
    grid.appendChild(s);
  }

  // 2) center dark '+' cluster (like the mock)
  const ghost = (c,r) => {
    const g = document.createElement('i');
    g.className = 'hf-ghost';
    g.style.gridColumn = String(c);
    g.style.gridRow    = String(r);
    grid.appendChild(g);
  };
  // plus centered roughly midframe
  ghost(5,7); ghost(4,7); ghost(6,7); ghost(5,6); ghost(5,8);


  // Other bright ghosts apart from the +
  const ghost2 = (c,r) => {
    const g = document.createElement('i');
    g.className = 'hf-ghost2';
    g.style.gridColumn = String(c);
    g.style.gridRow    = String(r);
    grid.appendChild(g);
  };
//locations
ghost2(4,8); ghost2(4,9);

const ghost3 = (c,r) => {
    const g = document.createElement('i');
    g.className = 'hf-ghost3';
    g.style.gridColumn = String(c);
    g.style.gridRow    = String(r);
    grid.appendChild(g);
  };
//locations
ghost3(4,10);

const ghost4 = (c,r) => {
    const g = document.createElement('i');
    g.className = 'hf-ghost4';
    g.style.gridColumn = String(c);
    g.style.gridRow    = String(r);
    grid.appendChild(g);
  };
//locations
ghost4(3,10); ghost4(5,10);

const ghost5 = (c,r) => {
    const g = document.createElement('i');
    g.className = 'hf-ghost5';
    g.style.gridColumn = String(c);
    g.style.gridRow    = String(r);
    grid.appendChild(g);
  };
//locations
ghost5(2,10);

const ghost6 = (c,r) => {
    const g = document.createElement('i');
    g.className = 'hf-ghost6';
    g.style.gridColumn = String(c);
    g.style.gridRow    = String(r);
    grid.appendChild(g);
  };
//locations
ghost6(6,10);

const ghost7 = (c,r) => {
    const g = document.createElement('i');
    g.className = 'hf-ghost7';
    g.style.gridColumn = String(c);
    g.style.gridRow    = String(r);
    grid.appendChild(g);
  };
//locations
ghost7(5,9);

const ghost8 = (c,r) => {
    const g = document.createElement('i');
    g.className = 'hf-ghost8';
    g.style.gridColumn = String(c);
    g.style.gridRow    = String(r);
    grid.appendChild(g);
  };
//locations
ghost8(6,9);

const ghost9 = (c,r) => {
    const g = document.createElement('i');
    g.className = 'hf-ghost9';
    g.style.gridColumn = String(c);
    g.style.gridRow    = String(r);
    grid.appendChild(g);
  };
//locations
ghost9(1,2);

const ghost10 = (c,r) => {
    const g = document.createElement('i');
    g.className = 'hf-ghost10';
    g.style.gridColumn = String(c);
    g.style.gridRow    = String(r);
    grid.appendChild(g);
  };
//locations
ghost10(2,3); ghost10(2,4);

const ghost11 = (c,r) => {
    const g = document.createElement('i');
    g.className = 'hf-ghost11';
    g.style.gridColumn = String(c);
    g.style.gridRow    = String(r);
    grid.appendChild(g);
  };
//locations
ghost11(1,1); ghost11(3,1); ghost11(4,1); ghost11(2,2); ghost11(3,2); ghost11(4,2); ghost11(3,3); ghost11(4,3); ghost11(5,2); ghost11(2,1); ghost11(3,4);
  //3) colored blocks in fixed spots (pixel-matched layout)
  const drop = (c,r,cls) => {
    const b = document.createElement('b');
    b.className = 'hf-block ' + cls;
    b.style.gridColumn = String(c);
    b.style.gridRow    = String(r);
    grid.appendChild(b);
  };

  // cyan singles (left/top & mid-left)
  drop(1,3,'hf-cyan');
  drop(1,4,'hf-cyan');
  drop(2,7,'hf-cyan');

  // magenta vertical stacks on right (top & lower)
  [4,5].forEach(r => drop(8,r,'hf-magenta'));
  [8,9].forEach(r => drop(8,r,'hf-magenta'));
  [10].forEach(r => drop(7,r,'hf-magenta'));

  // bottom-left and bottom-right corner singles (magenta)
  drop(1,12,'hf-magenta');
  drop(8,12,'hf-magenta');
  drop(1,10,'hf-magenta');
  

  // orange L near bottom-left
  drop(2,9,'hf-orange');
  drop(3,9,'hf-orange');
  drop(3,8,'hf-orange');
  

  grid.dataset.built = '1';

  // 4) mini cards â€” draw shapes
  const cards = document.querySelectorAll('#homeOverlay .hf-card');
  if (cards.length === 3){
    // helper to place small blocks on a 4Ã—3 mini grid
    const mini = (el, coords, cls) => {
      const m = document.createElement('div'); m.className = 'hf-mini';
      // 4 cols Ã— 3 rows grid space
      const index = (x,y)=> y*4 + x;
      for(let i=0;i<12;i++){
        const d=document.createElement('i'); d.className='b'; m.appendChild(d);
      }
      coords.forEach(([x,y])=>{
        const cell = m.children[index(x,y)];
        if(cell) cell.classList.add(cls);
      });
      el.innerHTML=''; el.appendChild(m);
    };
    // Left card: magenta little L (3 blocks)
    mini(cards[0], [[1,1],[2,0]], 'mag');
    // Middle card: violet T (4 blocks)
    mini(cards[1], [[1,2],[0,1],[1,1],[2,1]], 'vio');
    // Right card: orange 3 horizontal
    mini(cards[2], [[0,1],[1,1],[2,1]], 'orn');
  }
}

// show/hide overlay (keeps your existing nav)
function showHomeOverlay(){ document.getElementById('homeOverlay')?.classList.add('show'); }
function hideHomeOverlay(){ document.getElementById('homeOverlay')?.classList.remove('show'); }

window.addEventListener('DOMContentLoaded', ()=>{
  showHome();
  runSelfTests();
  fitTetrisToViewport();

  initHomeArt();
  showHomeOverlay();
  fitHomeOverlay();                      // <â€” NEW
  requestAnimationFrame(fitHomeOverlay); // <â€” NEW (wait one frame for CSS to apply)
  setTimeout(fitHomeOverlay, 250); // <â€” NEW (in case fonts/images load late)
  document.getElementById('hfPlay')?.addEventListener('click', ()=>{
    hideHomeOverlay();
  });
});

window.addEventListener('resize', fitHomeOverlay, { passive:true });
window.addEventListener('orientationchange', () => setTimeout(fitHomeOverlay, 50), { passive:true });
document.fonts?.ready?.then?.(fitHomeOverlay);
window.visualViewport?.addEventListener?.('resize', fitHomeOverlay, { passive: true });

// Re-fit if the inside card reflows (only if the element exists)
document.addEventListener('DOMContentLoaded', () => {
  const phone = document.querySelector('#homeOverlay .hf-phone');
  if (phone && 'ResizeObserver' in window) {
    const ro = new ResizeObserver(() => fitHomeOverlay());
    ro.observe(phone);
  }
});




// Fit the portrait card into the real viewport (handles toolbars/URL bars)
function fitHomeOverlay(){
  const overlay = document.getElementById('homeOverlay');
  const phone   = overlay?.querySelector('.hf-phone');
  if (!overlay || !phone) return;

  // Reset to natural size to measure
  phone.style.transform = 'none';
  phone.style.marginTop = phone.style.marginBottom = '0px';

  // Prefer visualViewport (excludes browser UI), fall back to window
  const vw = (window.visualViewport?.width  ?? window.innerWidth);
  const vh = (window.visualViewport?.height ?? window.innerHeight);

  // Padding budget so it never kisses the edges
  const pad = 24;
  const availW = Math.max(280, vw - pad * 2);
  const availH = Math.max(360, vh - pad * 2);

  const rect = phone.getBoundingClientRect();
  const scale = Math.min(1, availW / rect.width, availH / rect.height);

  phone.style.transform       = `scale(${scale})`;
  phone.style.transformOrigin = 'top center';

  // Center vertically after scaling
  const usedH = rect.height * scale;
  const margin = Math.max(0, (availH - usedH) / 2);
  phone.style.marginTop    = `${margin}px`;
  phone.style.marginBottom = `${margin}px`;
}




// If the demo didn't start for some reason on mobile, kick it on first tap.
window.addEventListener('pointerdown', () => {
  try { if (document.getElementById('home') && !document.getElementById('home').classList.contains('hidden')) {
    // If home is visible, ensure demo is running
    if (typeof startDemo === 'function') startDemo();
  }} catch(e){}
}, { once:true });

// Debug helper: log which element is on top where you tap
document.addEventListener('pointerdown', (e) => {
  const el = document.elementFromPoint(e.clientX, e.clientY);
  if (el) console.log('Tapped element:', el.tagName, el.id, el.className);
}, { passive:true });



/* ===== Service Worker: update prompt flow ===== */
(function setupSWUpdatePrompt(){
  if (!('serviceWorker' in navigator)) return;

  let newWorkerWaiting = null;
  let refreshing = false;

  function showToast(){
    const el = document.getElementById('updateToast');
    if(!el) return;
    el.classList.add('show');
    const later = document.getElementById('updateLaterBtn');
    const now   = document.getElementById('updateNowBtn');

    // Hide only
    later.onclick = () => el.classList.remove('show');

    // Ask waiting worker to become active, then page will reload once
    now.onclick = () => {
      if (newWorkerWaiting) {
        newWorkerWaiting.postMessage({ type: 'SKIP_WAITING' });
      }
    };
  }

  // When controller changes, the new SW took control -> safe to reload once
  navigator.serviceWorker.addEventListener('controllerchange', () => {
    if (refreshing) return;
    refreshing = true;
    // If you want to protect in-play sessions, you could persist state here first.
    location.reload();
  });

  window.addEventListener('load', async () => {
    try {
      const reg = await navigator.serviceWorker.register('./sw.js', { scope: './' });
      // If a new service worker is found
      reg.addEventListener('updatefound', () => {
        const installing = reg.installing;
        if (!installing) return;

        installing.addEventListener('statechange', () => {
          // When the new SW is installed and we already have a controller,
          // it means an update is ready (waiting) rather than first install.
          if (installing.state === 'installed' && navigator.serviceWorker.controller) {
            newWorkerWaiting = reg.waiting;
            showToast();
          }
        });
      });

      // Also handle the case where the new worker is already waiting (fast check)
      if (reg.waiting && navigator.serviceWorker.controller) {
        newWorkerWaiting = reg.waiting;
        showToast();
      }
    } catch (err) {
      console.error('SW registration failed', err);
    }
  });
})();


/* Unlock audio once the user taps/clicks */
let audioOK = false;
window.addEventListener('pointerdown', () => { audioOK = true; }, { once:true });

if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      // Register sw.js at the project root scope
      const reg = await navigator.serviceWorker.register('./sw.js', { scope: './' });
      console.log('[SW] Registered:', reg.scope);

      // Periodically ask for updates while the page is open
      setInterval(() => reg.update(), 30_000);

      // If a new SW is found, tell it to activate right away
      function enableInstantUpdates(swReg) {
        if (!swReg) return;

        // If a new worker is already waiting, tell it to take over
        if (swReg.waiting) {
          swReg.waiting.postMessage({ type: 'SKIP_WAITING' });
        }

        // When a new worker appears, skip waiting after itâ€™s installed
        swReg.addEventListener('updatefound', () => {
          const installing = swReg.installing;
          if (!installing) return;
          installing.addEventListener('statechange', () => {
            if (installing.state === 'installed' && navigator.serviceWorker.controller) {
              installing.postMessage({ type: 'SKIP_WAITING' });
            }
          });
        });
      }
      enableInstantUpdates(reg);

   
     

    } catch (err) {
      console.error('[SW] registration failed:', err);
    }
  });
}


</script>
<!-- ===== NEON HOME OVERLAY (first screen) ===== -->
<!-- ===== NEON PORTRAIT HOME (exact mock) ===== -->
<div id="homeOverlay" aria-hidden="true">
  <div class="hf-phone">
    <div class="hf-board">
      <div class="hf-sparkles" aria-hidden="true"></div>

      <h1 class="hf-title">
        <span>BLOCK</span><br><span>FORGE</span>
      </h1>

      <!-- mini 8Ã—12 grid + decorative blocks (filled by JS) -->
      <div id="hfGrid" class="hf-grid" aria-hidden="true"></div>
    </div>

    <button id="hfPlay" class="hf-cta">PLAY</button>

    <div class="hf-tray">
      <div class="hf-card"><div class="hf-piece p1"></div></div>
      <div class="hf-card"><div class="hf-piece p2"></div></div>
      <div class="hf-card"><div class="hf-piece p3"></div></div>
    </div>
  </div>
</div>


<!-- Update prompt toast -->
<div id="updateToast" role="status" aria-live="polite" class="hidden">
  <span>New version available</span>
  <button id="updateLaterBtn" type="button">Later</button>
  <button id="updateNowBtn" class="primary" type="button">Refresh</button>
</div>
<script>
(() => {
  function wrapHome(){
    const home = document.getElementById('homeOverlay');
    if (!home) return console.warn('fitstage: #homeOverlay not found');

    // Already wrapped? exit.
    if (home.closest('.fitstage')) return;

    // Create wrappers
    const stage = document.createElement('div');
    stage.className = 'fitstage';
    const box = document.createElement('div');
    box.className = 'fitbox';

    // Insert stage where #homeOverlay currently sits
    const parent = home.parentNode;
    parent.insertBefore(stage, home);
    stage.appendChild(box);
    box.appendChild(home); // move your existing overlay inside the fitbox
  }

  // run after DOM is parsed
  (document.readyState === 'loading')
    ? document.addEventListener('DOMContentLoaded', wrapHome, { once:true })
    : wrapHome();
})();


</script>
<script>
(function(){
  function setVH(){
    var vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--app-h', (vh*100) + 'px');
  }
  setVH();
  addEventListener('resize', setVH);
  addEventListener('orientationchange', setVH);
})();
</script>

</body>
</html>